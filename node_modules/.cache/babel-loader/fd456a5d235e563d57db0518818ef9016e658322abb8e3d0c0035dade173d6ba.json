{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es.number.is-nan.js\";\nimport \"core-js/modules/es.number.parse-float.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { inject, ref, computed, nextTick, watch } from 'vue';\nimport { debounce } from 'lodash-unified';\nimport { useEventListener } from '@vueuse/core';\nimport { sliderContextKey } from '../constants.mjs';\nimport { EVENT_CODE } from '../../../../constants/aria.mjs';\nimport { UPDATE_MODEL_EVENT } from '../../../../constants/event.mjs';\nvar useTooltip = function useTooltip(props, formatTooltip, showTooltip) {\n  var tooltip = ref();\n  var tooltipVisible = ref(false);\n  var enableFormat = computed(function () {\n    return formatTooltip.value instanceof Function;\n  });\n  var formatValue = computed(function () {\n    return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;\n  });\n  var displayTooltip = debounce(function () {\n    showTooltip.value && (tooltipVisible.value = true);\n  }, 50);\n  var hideTooltip = debounce(function () {\n    showTooltip.value && (tooltipVisible.value = false);\n  }, 50);\n  return {\n    tooltip: tooltip,\n    tooltipVisible: tooltipVisible,\n    formatValue: formatValue,\n    displayTooltip: displayTooltip,\n    hideTooltip: hideTooltip\n  };\n};\nvar useSliderButton = function useSliderButton(props, initData, emit) {\n  var _inject = inject(sliderContextKey),\n    disabled = _inject.disabled,\n    min = _inject.min,\n    max = _inject.max,\n    step = _inject.step,\n    showTooltip = _inject.showTooltip,\n    precision = _inject.precision,\n    sliderSize = _inject.sliderSize,\n    formatTooltip = _inject.formatTooltip,\n    emitChange = _inject.emitChange,\n    resetSize = _inject.resetSize,\n    updateDragging = _inject.updateDragging;\n  var _useTooltip = useTooltip(props, formatTooltip, showTooltip),\n    tooltip = _useTooltip.tooltip,\n    tooltipVisible = _useTooltip.tooltipVisible,\n    formatValue = _useTooltip.formatValue,\n    displayTooltip = _useTooltip.displayTooltip,\n    hideTooltip = _useTooltip.hideTooltip;\n  var button = ref();\n  var currentPosition = computed(function () {\n    return \"\".concat((props.modelValue - min.value) / (max.value - min.value) * 100, \"%\");\n  });\n  var wrapperStyle = computed(function () {\n    return props.vertical ? {\n      bottom: currentPosition.value\n    } : {\n      left: currentPosition.value\n    };\n  });\n  var handleMouseEnter = function handleMouseEnter() {\n    initData.hovering = true;\n    displayTooltip();\n  };\n  var handleMouseLeave = function handleMouseLeave() {\n    initData.hovering = false;\n    if (!initData.dragging) {\n      hideTooltip();\n    }\n  };\n  var onButtonDown = function onButtonDown(event) {\n    if (disabled.value) return;\n    event.preventDefault();\n    onDragStart(event);\n    window.addEventListener(\"mousemove\", onDragging);\n    window.addEventListener(\"touchmove\", onDragging);\n    window.addEventListener(\"mouseup\", _onDragEnd);\n    window.addEventListener(\"touchend\", _onDragEnd);\n    window.addEventListener(\"contextmenu\", _onDragEnd);\n    button.value.focus();\n  };\n  var incrementPosition = function incrementPosition(amount) {\n    if (disabled.value) return;\n    initData.newPosition = Number.parseFloat(currentPosition.value) + amount / (max.value - min.value) * 100;\n    setPosition(initData.newPosition);\n    emitChange();\n  };\n  var onLeftKeyDown = function onLeftKeyDown() {\n    incrementPosition(-step.value);\n  };\n  var onRightKeyDown = function onRightKeyDown() {\n    incrementPosition(step.value);\n  };\n  var onPageDownKeyDown = function onPageDownKeyDown() {\n    incrementPosition(-step.value * 4);\n  };\n  var onPageUpKeyDown = function onPageUpKeyDown() {\n    incrementPosition(step.value * 4);\n  };\n  var onHomeKeyDown = function onHomeKeyDown() {\n    if (disabled.value) return;\n    setPosition(0);\n    emitChange();\n  };\n  var onEndKeyDown = function onEndKeyDown() {\n    if (disabled.value) return;\n    setPosition(100);\n    emitChange();\n  };\n  var onKeyDown = function onKeyDown(event) {\n    var isPreventDefault = true;\n    switch (event.code) {\n      case EVENT_CODE.left:\n      case EVENT_CODE.down:\n        onLeftKeyDown();\n        break;\n      case EVENT_CODE.right:\n      case EVENT_CODE.up:\n        onRightKeyDown();\n        break;\n      case EVENT_CODE.home:\n        onHomeKeyDown();\n        break;\n      case EVENT_CODE.end:\n        onEndKeyDown();\n        break;\n      case EVENT_CODE.pageDown:\n        onPageDownKeyDown();\n        break;\n      case EVENT_CODE.pageUp:\n        onPageUpKeyDown();\n        break;\n      default:\n        isPreventDefault = false;\n        break;\n    }\n    isPreventDefault && event.preventDefault();\n  };\n  var getClientXY = function getClientXY(event) {\n    var clientX;\n    var clientY;\n    if (event.type.startsWith(\"touch\")) {\n      clientY = event.touches[0].clientY;\n      clientX = event.touches[0].clientX;\n    } else {\n      clientY = event.clientY;\n      clientX = event.clientX;\n    }\n    return {\n      clientX: clientX,\n      clientY: clientY\n    };\n  };\n  var onDragStart = function onDragStart(event) {\n    initData.dragging = true;\n    initData.isClick = true;\n    var _getClientXY = getClientXY(event),\n      clientX = _getClientXY.clientX,\n      clientY = _getClientXY.clientY;\n    if (props.vertical) {\n      initData.startY = clientY;\n    } else {\n      initData.startX = clientX;\n    }\n    initData.startPosition = Number.parseFloat(currentPosition.value);\n    initData.newPosition = initData.startPosition;\n  };\n  var onDragging = function onDragging(event) {\n    if (initData.dragging) {\n      initData.isClick = false;\n      displayTooltip();\n      resetSize();\n      var diff;\n      var _getClientXY2 = getClientXY(event),\n        clientX = _getClientXY2.clientX,\n        clientY = _getClientXY2.clientY;\n      if (props.vertical) {\n        initData.currentY = clientY;\n        diff = (initData.startY - initData.currentY) / sliderSize.value * 100;\n      } else {\n        initData.currentX = clientX;\n        diff = (initData.currentX - initData.startX) / sliderSize.value * 100;\n      }\n      initData.newPosition = initData.startPosition + diff;\n      setPosition(initData.newPosition);\n    }\n  };\n  var _onDragEnd = function onDragEnd() {\n    if (initData.dragging) {\n      setTimeout(function () {\n        initData.dragging = false;\n        if (!initData.hovering) {\n          hideTooltip();\n        }\n        if (!initData.isClick) {\n          setPosition(initData.newPosition);\n        }\n        emitChange();\n      }, 0);\n      window.removeEventListener(\"mousemove\", onDragging);\n      window.removeEventListener(\"touchmove\", onDragging);\n      window.removeEventListener(\"mouseup\", _onDragEnd);\n      window.removeEventListener(\"touchend\", _onDragEnd);\n      window.removeEventListener(\"contextmenu\", _onDragEnd);\n    }\n  };\n  var setPosition = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(newPosition) {\n      var lengthPerStep, steps, value;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!(newPosition === null || Number.isNaN(+newPosition))) {\n              _context.next = 2;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 2:\n            if (newPosition < 0) {\n              newPosition = 0;\n            } else if (newPosition > 100) {\n              newPosition = 100;\n            }\n            lengthPerStep = 100 / ((max.value - min.value) / step.value);\n            steps = Math.round(newPosition / lengthPerStep);\n            value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;\n            value = Number.parseFloat(value.toFixed(precision.value));\n            if (value !== props.modelValue) {\n              emit(UPDATE_MODEL_EVENT, value);\n            }\n            if (!initData.dragging && props.modelValue !== initData.oldValue) {\n              initData.oldValue = props.modelValue;\n            }\n            _context.next = 11;\n            return nextTick();\n          case 11:\n            initData.dragging && displayTooltip();\n            tooltip.value.updatePopper();\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function setPosition(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  watch(function () {\n    return initData.dragging;\n  }, function (val) {\n    updateDragging(val);\n  });\n  useEventListener(button, \"touchstart\", onButtonDown, {\n    passive: false\n  });\n  return {\n    disabled: disabled,\n    button: button,\n    tooltip: tooltip,\n    tooltipVisible: tooltipVisible,\n    showTooltip: showTooltip,\n    wrapperStyle: wrapperStyle,\n    formatValue: formatValue,\n    handleMouseEnter: handleMouseEnter,\n    handleMouseLeave: handleMouseLeave,\n    onButtonDown: onButtonDown,\n    onKeyDown: onKeyDown,\n    setPosition: setPosition\n  };\n};\nexport { useSliderButton };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}