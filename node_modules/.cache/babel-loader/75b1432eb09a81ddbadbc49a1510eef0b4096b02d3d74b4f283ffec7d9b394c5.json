{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nimport { inject, getCurrentInstance, computed, watch, nextTick } from 'vue';\nimport { checkboxGroupContextKey } from '../constants.mjs';\nimport { useFormItem } from '../../../form/src/hooks/use-form-item.mjs';\nimport { debugWarn } from '../../../../utils/error.mjs';\nvar useCheckboxEvent = function useCheckboxEvent(props, _ref) {\n  var model = _ref.model,\n    isLimitExceeded = _ref.isLimitExceeded,\n    hasOwnLabel = _ref.hasOwnLabel,\n    isDisabled = _ref.isDisabled,\n    isLabeledByFormItem = _ref.isLabeledByFormItem;\n  var checkboxGroup = inject(checkboxGroupContextKey, void 0);\n  var _useFormItem = useFormItem(),\n    formItem = _useFormItem.formItem;\n  var _getCurrentInstance = getCurrentInstance(),\n    emit = _getCurrentInstance.emit;\n  function getLabeledValue(value) {\n    var _a, _b, _c, _d;\n    return [true, props.trueValue, props.trueLabel].includes(value) ? (_b = (_a = props.trueValue) != null ? _a : props.trueLabel) != null ? _b : true : (_d = (_c = props.falseValue) != null ? _c : props.falseLabel) != null ? _d : false;\n  }\n  function emitChangeEvent(checked, e) {\n    emit(\"change\", getLabeledValue(checked), e);\n  }\n  function handleChange(e) {\n    if (isLimitExceeded.value) return;\n    var target = e.target;\n    emit(\"change\", getLabeledValue(target.checked), e);\n  }\n  function onClickRoot(_x) {\n    return _onClickRoot.apply(this, arguments);\n  }\n  function _onClickRoot() {\n    _onClickRoot = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(e) {\n      var eventTargets, hasLabel;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!isLimitExceeded.value) {\n              _context.next = 2;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 2:\n            if (!(!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value)) {\n              _context.next = 10;\n              break;\n            }\n            eventTargets = e.composedPath();\n            hasLabel = eventTargets.some(function (item) {\n              return item.tagName === \"LABEL\";\n            });\n            if (hasLabel) {\n              _context.next = 10;\n              break;\n            }\n            model.value = getLabeledValue([false, props.falseValue, props.falseLabel].includes(model.value));\n            _context.next = 9;\n            return nextTick();\n          case 9:\n            emitChangeEvent(model.value, e);\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return _onClickRoot.apply(this, arguments);\n  }\n  var validateEvent = computed(function () {\n    return (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent;\n  });\n  watch(function () {\n    return props.modelValue;\n  }, function () {\n    if (validateEvent.value) {\n      formItem == null ? void 0 : formItem.validate(\"change\")[\"catch\"](function (err) {\n        return debugWarn(err);\n      });\n    }\n  });\n  return {\n    handleChange: handleChange,\n    onClickRoot: onClickRoot\n  };\n};\nexport { useCheckboxEvent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}