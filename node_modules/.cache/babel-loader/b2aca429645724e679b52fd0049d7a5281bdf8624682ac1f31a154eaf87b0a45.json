{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { defineComponent, ref, provide, watch, unref, onMounted, onBeforeUnmount, nextTick, renderSlot } from 'vue';\nimport { isNil } from 'lodash-unified';\nimport { useFocusReason, tryFocus, createFocusOutPreventedEvent, getEdges, focusableStack, focusFirstDescendant, obtainAllFocusableElements, isFocusCausedByUserEvent } from './utils.mjs';\nimport { ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, FOCUS_TRAP_INJECTION_KEY, FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS, FOCUS_AFTER_RELEASED } from './tokens.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useEscapeKeydown } from '../../../hooks/use-escape-keydown/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { isString } from '@vue/shared';\nvar _sfc_main = defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object,\n    focusStartEl: {\n      type: [Object, String],\n      \"default\": \"first\"\n    }\n  },\n  emits: [ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, \"focusin\", \"focusout\", \"focusout-prevented\", \"release-requested\"],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n    var forwardRef = ref();\n    var lastFocusBeforeTrapped;\n    var lastFocusAfterTrapped;\n    var _useFocusReason = useFocusReason(),\n      focusReason = _useFocusReason.focusReason;\n    useEscapeKeydown(function (event) {\n      if (props.trapped && !focusLayer.paused) {\n        emit(\"release-requested\", event);\n      }\n    });\n    var focusLayer = {\n      paused: false,\n      pause: function pause() {\n        this.paused = true;\n      },\n      resume: function resume() {\n        this.paused = false;\n      }\n    };\n    var onKeydown = function onKeydown(e) {\n      if (!props.loop && !props.trapped) return;\n      if (focusLayer.paused) return;\n      var code = e.code,\n        altKey = e.altKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        currentTarget = e.currentTarget,\n        shiftKey = e.shiftKey;\n      var loop = props.loop;\n      var isTabbing = code === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      var currentFocusingEl = document.activeElement;\n      if (isTabbing && currentFocusingEl) {\n        var container = currentTarget;\n        var _getEdges = getEdges(container),\n          _getEdges2 = _slicedToArray(_getEdges, 2),\n          first = _getEdges2[0],\n          last = _getEdges2[1];\n        var isTabbable = first && last;\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            var focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            var _focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", _focusoutPreventedEvent);\n            if (!_focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop) tryFocus(first, true);\n            }\n          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {\n            var _focusoutPreventedEvent2 = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", _focusoutPreventedEvent2);\n            if (!_focusoutPreventedEvent2.defaultPrevented) {\n              e.preventDefault();\n              if (loop) tryFocus(last, true);\n            }\n          }\n        }\n      }\n    };\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown: onKeydown\n    });\n    watch(function () {\n      return props.focusTrapEl;\n    }, function (focusTrapEl) {\n      if (focusTrapEl) {\n        forwardRef.value = focusTrapEl;\n      }\n    }, {\n      immediate: true\n    });\n    watch([forwardRef], function (_ref2, _ref3) {\n      var _ref4 = _slicedToArray(_ref2, 1),\n        forwardRef2 = _ref4[0];\n      var _ref5 = _slicedToArray(_ref3, 1),\n        oldForwardRef = _ref5[0];\n      if (forwardRef2) {\n        forwardRef2.addEventListener(\"keydown\", onKeydown);\n        forwardRef2.addEventListener(\"focusin\", onFocusIn);\n        forwardRef2.addEventListener(\"focusout\", onFocusOut);\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener(\"keydown\", onKeydown);\n        oldForwardRef.removeEventListener(\"focusin\", onFocusIn);\n        oldForwardRef.removeEventListener(\"focusout\", onFocusOut);\n      }\n    });\n    var trapOnFocus = function trapOnFocus(e) {\n      emit(ON_TRAP_FOCUS_EVT, e);\n    };\n    var releaseOnFocus = function releaseOnFocus(e) {\n      return emit(ON_RELEASE_FOCUS_EVT, e);\n    };\n    var onFocusIn = function onFocusIn(e) {\n      var trapContainer = unref(forwardRef);\n      if (!trapContainer) return;\n      var target = e.target;\n      var relatedTarget = e.relatedTarget;\n      var isFocusedInTrap = target && trapContainer.contains(target);\n      if (!props.trapped) {\n        var isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget;\n        }\n      }\n      if (isFocusedInTrap) emit(\"focusin\", e);\n      if (focusLayer.paused) return;\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target;\n        } else {\n          tryFocus(lastFocusAfterTrapped, true);\n        }\n      }\n    };\n    var onFocusOut = function onFocusOut(e) {\n      var trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n      if (props.trapped) {\n        var relatedTarget = e.relatedTarget;\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          setTimeout(function () {\n            if (!focusLayer.paused && props.trapped) {\n              var focusoutPreventedEvent = createFocusOutPreventedEvent({\n                focusReason: focusReason.value\n              });\n              emit(\"focusout-prevented\", focusoutPreventedEvent);\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                tryFocus(lastFocusAfterTrapped, true);\n              }\n            }\n          }, 0);\n        }\n      } else {\n        var target = e.target;\n        var isFocusedInTrap = target && trapContainer.contains(target);\n        if (!isFocusedInTrap) emit(\"focusout\", e);\n      }\n    };\n    function startTrap() {\n      return _startTrap.apply(this, arguments);\n    }\n    function _startTrap() {\n      _startTrap = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var trapContainer, prevFocusedElement, isPrevFocusContained, focusEvent;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return nextTick();\n            case 2:\n              trapContainer = unref(forwardRef);\n              if (trapContainer) {\n                focusableStack.push(focusLayer);\n                prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;\n                lastFocusBeforeTrapped = prevFocusedElement;\n                isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n                if (!isPrevFocusContained) {\n                  focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);\n                  trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n                  trapContainer.dispatchEvent(focusEvent);\n                  if (!focusEvent.defaultPrevented) {\n                    nextTick(function () {\n                      var focusStartEl = props.focusStartEl;\n                      if (!isString(focusStartEl)) {\n                        tryFocus(focusStartEl);\n                        if (document.activeElement !== focusStartEl) {\n                          focusStartEl = \"first\";\n                        }\n                      }\n                      if (focusStartEl === \"first\") {\n                        focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);\n                      }\n                      if (document.activeElement === prevFocusedElement || focusStartEl === \"container\") {\n                        tryFocus(trapContainer);\n                      }\n                    });\n                  }\n                }\n              }\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return _startTrap.apply(this, arguments);\n    }\n    function stopTrap() {\n      var trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n        var releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, _objectSpread(_objectSpread({}, FOCUS_AFTER_TRAPPED_OPTS), {}, {\n          detail: {\n            focusReason: focusReason.value\n          }\n        }));\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);\n        trapContainer.dispatchEvent(releasedEvent);\n        if (!releasedEvent.defaultPrevented && (focusReason.value == \"keyboard\" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {\n          tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);\n        }\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);\n        focusableStack.remove(focusLayer);\n      }\n    }\n    onMounted(function () {\n      if (props.trapped) {\n        startTrap();\n      }\n      watch(function () {\n        return props.trapped;\n      }, function (trapped) {\n        if (trapped) {\n          startTrap();\n        } else {\n          stopTrap();\n        }\n      });\n    });\n    onBeforeUnmount(function () {\n      if (props.trapped) {\n        stopTrap();\n      }\n      if (forwardRef.value) {\n        forwardRef.value.removeEventListener(\"keydown\", onKeydown);\n        forwardRef.value.removeEventListener(\"focusin\", onFocusIn);\n        forwardRef.value.removeEventListener(\"focusout\", onFocusOut);\n        forwardRef.value = void 0;\n      }\n    });\n    return {\n      onKeydown: onKeydown\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return renderSlot(_ctx.$slots, \"default\", {\n    handleKeydown: _ctx.onKeydown\n  });\n}\nvar ElFocusTrap = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"focus-trap.vue\"]]);\nexport { ElFocusTrap as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}