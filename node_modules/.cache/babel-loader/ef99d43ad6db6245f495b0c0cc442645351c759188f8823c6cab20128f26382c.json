{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.number.is-nan.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport { nextTick } from 'vue';\nimport { throttle } from 'lodash-unified';\nimport { isFunction } from '@vue/shared';\nimport { throwError } from '../../../utils/error.mjs';\nimport { getScrollContainer } from '../../../utils/dom/scroll.mjs';\nimport { getOffsetTopDistance } from '../../../utils/dom/position.mjs';\nvar SCOPE = \"ElInfiniteScroll\";\nvar CHECK_INTERVAL = 50;\nvar DEFAULT_DELAY = 200;\nvar DEFAULT_DISTANCE = 0;\nvar attributes = {\n  delay: {\n    type: Number,\n    \"default\": DEFAULT_DELAY\n  },\n  distance: {\n    type: Number,\n    \"default\": DEFAULT_DISTANCE\n  },\n  disabled: {\n    type: Boolean,\n    \"default\": false\n  },\n  immediate: {\n    type: Boolean,\n    \"default\": true\n  }\n};\nvar getScrollOptions = function getScrollOptions(el, instance) {\n  return Object.entries(attributes).reduce(function (acm, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      name = _ref2[0],\n      option = _ref2[1];\n    var _a, _b;\n    var type = option.type,\n      defaultValue = option[\"default\"];\n    var attrVal = el.getAttribute(\"infinite-scroll-\".concat(name));\n    var value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;\n    value = value === \"false\" ? false : value;\n    value = type(value);\n    acm[name] = Number.isNaN(value) ? defaultValue : value;\n    return acm;\n  }, {});\n};\nvar destroyObserver = function destroyObserver(el) {\n  var observer = el[SCOPE].observer;\n  if (observer) {\n    observer.disconnect();\n    delete el[SCOPE].observer;\n  }\n};\nvar handleScroll = function handleScroll(el, cb) {\n  var _el$SCOPE = el[SCOPE],\n    container = _el$SCOPE.container,\n    containerEl = _el$SCOPE.containerEl,\n    instance = _el$SCOPE.instance,\n    observer = _el$SCOPE.observer,\n    lastScrollTop = _el$SCOPE.lastScrollTop;\n  var _getScrollOptions = getScrollOptions(el, instance),\n    disabled = _getScrollOptions.disabled,\n    distance = _getScrollOptions.distance;\n  var clientHeight = containerEl.clientHeight,\n    scrollHeight = containerEl.scrollHeight,\n    scrollTop = containerEl.scrollTop;\n  var delta = scrollTop - lastScrollTop;\n  el[SCOPE].lastScrollTop = scrollTop;\n  if (observer || disabled || delta < 0) return;\n  var shouldTrigger = false;\n  if (container === el) {\n    shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;\n  } else {\n    var clientTop = el.clientTop,\n      height = el.scrollHeight;\n    var offsetTop = getOffsetTopDistance(el, containerEl);\n    shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;\n  }\n  if (shouldTrigger) {\n    cb.call(instance);\n  }\n};\nfunction checkFull(el, cb) {\n  var _el$SCOPE2 = el[SCOPE],\n    containerEl = _el$SCOPE2.containerEl,\n    instance = _el$SCOPE2.instance;\n  var _getScrollOptions2 = getScrollOptions(el, instance),\n    disabled = _getScrollOptions2.disabled;\n  if (disabled || containerEl.clientHeight === 0) return;\n  if (containerEl.scrollHeight <= containerEl.clientHeight) {\n    cb.call(instance);\n  } else {\n    destroyObserver(el);\n  }\n}\nvar InfiniteScroll = {\n  mounted: function mounted(el, binding) {\n    return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var instance, cb, _getScrollOptions3, delay, immediate, container, containerEl, onScroll, observer;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            instance = binding.instance, cb = binding.value;\n            if (!isFunction(cb)) {\n              throwError(SCOPE, \"'v-infinite-scroll' binding value must be a function\");\n            }\n            _context.next = 4;\n            return nextTick();\n          case 4:\n            _getScrollOptions3 = getScrollOptions(el, instance), delay = _getScrollOptions3.delay, immediate = _getScrollOptions3.immediate;\n            container = getScrollContainer(el, true);\n            containerEl = container === window ? document.documentElement : container;\n            onScroll = throttle(handleScroll.bind(null, el, cb), delay);\n            if (container) {\n              _context.next = 10;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 10:\n            el[SCOPE] = {\n              instance: instance,\n              container: container,\n              containerEl: containerEl,\n              delay: delay,\n              cb: cb,\n              onScroll: onScroll,\n              lastScrollTop: containerEl.scrollTop\n            };\n            if (immediate) {\n              observer = new MutationObserver(throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));\n              el[SCOPE].observer = observer;\n              observer.observe(el, {\n                childList: true,\n                subtree: true\n              });\n              checkFull(el, cb);\n            }\n            container.addEventListener(\"scroll\", onScroll);\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  },\n  unmounted: function unmounted(el) {\n    if (!el[SCOPE]) return;\n    var _el$SCOPE3 = el[SCOPE],\n      container = _el$SCOPE3.container,\n      onScroll = _el$SCOPE3.onScroll;\n    container == null ? void 0 : container.removeEventListener(\"scroll\", onScroll);\n    destroyObserver(el);\n  },\n  updated: function updated(el) {\n    return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var _el$SCOPE4, containerEl, cb, observer;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (el[SCOPE]) {\n              _context2.next = 5;\n              break;\n            }\n            _context2.next = 3;\n            return nextTick();\n          case 3:\n            _context2.next = 7;\n            break;\n          case 5:\n            _el$SCOPE4 = el[SCOPE], containerEl = _el$SCOPE4.containerEl, cb = _el$SCOPE4.cb, observer = _el$SCOPE4.observer;\n            if (containerEl.clientHeight && observer) {\n              checkFull(el, cb);\n            }\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n};\nexport { CHECK_INTERVAL, DEFAULT_DELAY, DEFAULT_DISTANCE, SCOPE, InfiniteScroll as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}