{"ast":null,"code":"import _typeof from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport createList from '../builders/build-list.mjs';\nimport { isHorizontal } from '../utils.mjs';\nimport { AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, DEFAULT_DYNAMIC_LIST_ITEM_SIZE, SMART_ALIGNMENT } from '../defaults.mjs';\nimport { throwError } from '../../../../utils/error.mjs';\nvar SCOPE = \"ElDynamicSizeList\";\nvar getItemFromCache = function getItemFromCache(props, index, listCache) {\n  var itemSize = props.itemSize;\n  var items = listCache.items,\n    lastVisitedIndex = listCache.lastVisitedIndex;\n  if (index > lastVisitedIndex) {\n    var offset = 0;\n    if (lastVisitedIndex >= 0) {\n      var item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n    for (var i = lastVisitedIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      items[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n    listCache.lastVisitedIndex = index;\n  }\n  return items[index];\n};\nvar findItem = function findItem(props, listCache, offset) {\n  var items = listCache.items,\n    lastVisitedIndex = listCache.lastVisitedIndex;\n  var lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\nvar bs = function bs(props, listCache, low, high, offset) {\n  while (low <= high) {\n    var mid = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemFromCache(props, mid, listCache).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n  return Math.max(0, low - 1);\n};\nvar es = function es(props, listCache, index, offset) {\n  var total = props.total;\n  var exponent = 1;\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref, _ref2) {\n  var total = _ref.total;\n  var items = _ref2.items,\n    estimatedItemSize = _ref2.estimatedItemSize,\n    lastVisitedIndex = _ref2.lastVisitedIndex;\n  var totalSizeOfMeasuredItems = 0;\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n  if (lastVisitedIndex >= 0) {\n    var item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n  var numUnmeasuredItems = total - lastVisitedIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\nvar DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: function getItemOffset(props, index, listCache) {\n    return getItemFromCache(props, index, listCache).offset;\n  },\n  getItemSize: function getItemSize(_, index, _ref3) {\n    var items = _ref3.items;\n    return items[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffset: function getOffset(props, index, alignment, scrollOffset, listCache) {\n    var height = props.height,\n      layout = props.layout,\n      width = props.width;\n    var size = isHorizontal(layout) ? width : height;\n    var item = getItemFromCache(props, index, listCache);\n    var estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    var minOffset = Math.max(0, item.offset - size + item.size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n      case CENTERED_ALIGNMENT:\n        {\n          return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, listCache) {\n    return findItem(props, listCache, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, listCache) {\n    var height = props.height,\n      total = props.total,\n      layout = props.layout,\n      width = props.width;\n    var size = isHorizontal(layout) ? width : height;\n    var item = getItemFromCache(props, startIndex, listCache);\n    var maxOffset = scrollOffset + size;\n    var offset = item.offset + item.size;\n    var stopIndex = startIndex;\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n    return stopIndex;\n  },\n  initCache: function initCache(_ref4, instance) {\n    var _ref4$estimatedItemSi = _ref4.estimatedItemSize,\n      estimatedItemSize = _ref4$estimatedItemSi === void 0 ? DEFAULT_DYNAMIC_LIST_ITEM_SIZE : _ref4$estimatedItemSi;\n    var cache = {\n      items: {},\n      estimatedItemSize: estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n    cache.clearCacheAfterIndex = function (index) {\n      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var _a, _b;\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache(-1);\n      if (forceUpdate) {\n        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n      }\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, \"\\n          itemSize is required as function, but the given value was \".concat(_typeof(itemSize), \"\\n        \"));\n      }\n    }\n  }\n});\nexport { DynamicSizeList as default };","map":{"version":3,"names":["SCOPE","getItemFromCache","props","index","listCache","itemSize","items","lastVisitedIndex","offset","item","size","i","findItem","lastVisitedOffset","bs","es","Math","max","low","high","mid","floor","currentOffset","total","exponent","min","getEstimatedTotalSize","_ref","_ref2","estimatedItemSize","totalSizeOfMeasuredItems","numUnmeasuredItems","totalSizeOfUnmeasuredItems","DynamicSizeList","createList","name","getItemOffset","getItemSize","_","_ref3","getOffset","alignment","scrollOffset","height","layout","width","isHorizontal","estimatedTotalSize","maxOffset","minOffset","SMART_ALIGNMENT","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","round","getStartIndexForOffset","getStopIndexForStartIndex","startIndex","stopIndex","initCache","_ref4","instance","_ref4$estimatedItemSi","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","cache","clearCacheAfterIndex","forceUpdate","arguments","length","undefined","_a","_b","exposed","getItemStyleCache","proxy","$forceUpdate","clearCache","validateProps","_ref5","process","env","NODE_ENV","throwError","concat","_typeof"],"sources":["../../../../../../../packages/components/virtual-list/src/components/dynamic-size-list.ts"],"sourcesContent":["import { throwError } from '@element-plus/utils'\n\nimport createList from '../builders/build-list'\n\nimport { isHorizontal } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\nimport type { VirtualizedListProps } from '../props'\n\nimport type { ItemSize, ListCache, ListItem } from '../types'\n\ntype Props = VirtualizedListProps\n\nconst SCOPE = 'ElDynamicSizeList'\nconst getItemFromCache = (\n  props: Props,\n  index: number,\n  listCache: ListCache\n): ListItem => {\n  const { itemSize } = props\n  const { items, lastVisitedIndex } = listCache\n\n  if (index > lastVisitedIndex) {\n    let offset = 0\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex]\n      offset = item.offset + item.size\n    }\n\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = (itemSize as ItemSize)(i)\n\n      items[i] = {\n        offset,\n        size,\n      }\n\n      offset += size\n    }\n\n    listCache.lastVisitedIndex = index\n  }\n\n  return items[index]\n}\n\nconst findItem = (props: Props, listCache: ListCache, offset: number) => {\n  const { items, lastVisitedIndex } = listCache\n\n  const lastVisitedOffset =\n    lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0\n\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset)\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset)\n}\n\n// bs stands for binary search which has approximately time complexity of O(Log n)\n// space complexity of O(1)\n// in this case we use it for search the offset of each item, since\n// the cached items' offset is monotonically increasing\nconst bs = (\n  props: Props,\n  listCache: ListCache,\n  low: number,\n  high: number,\n  offset: number\n) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2)\n    const currentOffset = getItemFromCache(props, mid, listCache).offset\n\n    if (currentOffset === offset) {\n      return mid\n    } else if (currentOffset < offset) {\n      low = mid + 1\n    } else if (currentOffset > offset) {\n      high = mid - 1\n    }\n  }\n\n  return Math.max(0, low - 1)\n}\n\n// es stands for exponential search which has time complexity of O(Log n) and\n// space complexity of O(1) in the case of finding the boundary element.\n// the exponential indicator in this case is 2.\n// for more detail about exponential search click this link\n// https://www.freecodecamp.org/news/search-algorithms-exponential-search-explained/\n\nconst es = (\n  props: Props,\n  listCache: ListCache,\n  index: number,\n  offset: number\n) => {\n  const { total } = props\n  let exponent = 1\n\n  while (\n    index < total &&\n    getItemFromCache(props, index, listCache).offset < offset\n  ) {\n    index += exponent\n    exponent *= 2\n  }\n\n  return bs(\n    props,\n    listCache,\n    Math.floor(index / 2),\n    Math.min(index, total - 1),\n    offset\n  )\n}\n\nconst getEstimatedTotalSize = (\n  { total }: Props,\n  { items, estimatedItemSize, lastVisitedIndex }: ListCache\n) => {\n  let totalSizeOfMeasuredItems = 0\n\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1\n  }\n\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex]\n    totalSizeOfMeasuredItems = item.offset + item.size\n  }\n\n  const numUnmeasuredItems = total - lastVisitedIndex - 1\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems\n}\n\nconst DynamicSizeList = createList({\n  name: 'ElDynamicSizeList',\n  getItemOffset: (props, index, listCache) =>\n    getItemFromCache(props, index, listCache).offset,\n\n  getItemSize: (_, index, { items }) => items[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const { height, layout, width } = props\n\n    const size = (isHorizontal(layout) ? width : height) as number\n    const item = getItemFromCache(props, index, listCache)\n\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache)\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, item.offset)\n    )\n    const minOffset = Math.max(0, item.offset - size + item.size)\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset\n      }\n      case END_ALIGNMENT: {\n        return minOffset\n      }\n      case CENTERED_ALIGNMENT: {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2)\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset\n        } else if (scrollOffset < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n      }\n    }\n  },\n\n  getStartIndexForOffset: (props, offset, listCache) =>\n    findItem(props, listCache, offset),\n\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const { height, total, layout, width } = props\n\n    const size = (isHorizontal(layout) ? width : height) as number\n    const item = getItemFromCache(props, startIndex, listCache)\n    const maxOffset = scrollOffset + size\n\n    let offset = item.offset + item.size\n    let stopIndex = startIndex\n\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, stopIndex, listCache).size\n    }\n\n    return stopIndex\n  },\n\n  initCache({ estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1,\n    } as ListCache\n\n    cache.clearCacheAfterIndex = (index: number, forceUpdate = true) => {\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1)\n      instance.exposed?.getItemStyleCache(-1)\n\n      if (forceUpdate) {\n        instance.proxy?.$forceUpdate()\n      }\n    }\n\n    return cache\n  },\n\n  clearCache: false,\n\n  validateProps: ({ itemSize }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throwError(\n          SCOPE,\n          `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `\n        )\n      }\n    }\n  },\n})\n\nexport type DynamicSizeListInstance = InstanceType<typeof DynamicSizeList>\nexport default DynamicSizeList\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}