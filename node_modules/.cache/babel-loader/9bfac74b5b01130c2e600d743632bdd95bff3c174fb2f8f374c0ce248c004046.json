{"ast":null,"code":"import _typeof from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport createGrid from '../builders/build-grid.mjs';\nimport { DEFAULT_DYNAMIC_LIST_ITEM_SIZE, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, SMART_ALIGNMENT } from '../defaults.mjs';\nimport { isFunction } from '@vue/shared';\nimport { throwError } from '../../../../utils/error.mjs';\nimport { isNumber, isUndefined } from '../../../../utils/types.mjs';\nvar max = Math.max,\n  min = Math.min,\n  floor = Math.floor;\nvar SCOPE = \"ElDynamicSizeGrid\";\nvar ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nvar ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\nvar getItemFromCache = function getItemFromCache(props, index, gridCache, type) {\n  var _ref = [gridCache[type], props[ACCESS_SIZER_KEY_MAP[type]], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]],\n    cachedItems = _ref[0],\n    sizer = _ref[1],\n    lastVisited = _ref[2];\n  if (index > lastVisited) {\n    var offset = 0;\n    if (lastVisited >= 0) {\n      var item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n    for (var i = lastVisited + 1; i <= index; i++) {\n      var size = sizer(i);\n      cachedItems[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n  return cachedItems[index];\n};\nvar bs = function bs(props, gridCache, low, high, offset, type) {\n  while (low <= high) {\n    var mid = low + floor((high - low) / 2);\n    var currentOffset = getItemFromCache(props, mid, gridCache, type).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return max(0, low - 1);\n};\nvar es = function es(props, gridCache, idx, offset, type) {\n  var total = type === \"column\" ? props.totalColumn : props.totalRow;\n  var exponent = 1;\n  while (idx < total && getItemFromCache(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\nvar findItem = function findItem(props, gridCache, offset, type) {\n  var _ref2 = [gridCache[type], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]],\n    cache = _ref2[0],\n    lastVisitedIndex = _ref2[1];\n  var lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref3, _ref4) {\n  var totalRow = _ref3.totalRow;\n  var estimatedRowHeight = _ref4.estimatedRowHeight,\n    lastVisitedRowIndex = _ref4.lastVisitedRowIndex,\n    row = _ref4.row;\n  var sizeOfVisitedRows = 0;\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n  if (lastVisitedRowIndex >= 0) {\n    var item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n  var unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  var sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref5, _ref6) {\n  var totalColumn = _ref5.totalColumn;\n  var column = _ref6.column,\n    estimatedColumnWidth = _ref6.estimatedColumnWidth,\n    lastVisitedColumnIndex = _ref6.lastVisitedColumnIndex;\n  var sizeOfVisitedColumns = 0;\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n  if (lastVisitedColumnIndex >= 0) {\n    var item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n  var unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  var sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\nvar ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\nvar getOffset = function getOffset(props, index, alignment, scrollOffset, cache, type, scrollBarWidth) {\n  var _ref7 = [type === \"row\" ? props.height : props.width, ACCESS_ESTIMATED_SIZE_KEY_MAP[type]],\n    size = _ref7[0],\n    estimatedSizeAssociates = _ref7[1];\n  var item = getItemFromCache(props, index, cache, type);\n  var estimatedSize = estimatedSizeAssociates(props, cache);\n  var maxOffset = max(0, min(estimatedSize - size, item.offset));\n  var minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n  switch (alignment) {\n    case START_ALIGNMENT:\n      {\n        return maxOffset;\n      }\n    case END_ALIGNMENT:\n      {\n        return minOffset;\n      }\n    case CENTERED_ALIGNMENT:\n      {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n    case AUTO_ALIGNMENT:\n    default:\n      {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n  }\n};\nvar DynamicSizeGrid = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: function getColumnPosition(props, idx, cache) {\n    var item = getItemFromCache(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: function getRowPosition(props, idx, cache) {\n    var item = getItemFromCache(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: function getColumnOffset(props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) {\n    return getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth);\n  },\n  getRowOffset: function getRowOffset(props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) {\n    return getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth);\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, cache) {\n    return findItem(props, cache, scrollLeft, \"column\");\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, cache) {\n    var item = getItemFromCache(props, startIndex, cache, \"column\");\n    var maxOffset = scrollLeft + props.width;\n    var offset = item.offset + item.size;\n    var stopIndex = startIndex;\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, startIndex, cache, \"column\").size;\n    }\n    return stopIndex;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, cache) {\n    return findItem(props, cache, scrollTop, \"row\");\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, cache) {\n    var totalRow = props.totalRow,\n      height = props.height;\n    var item = getItemFromCache(props, startIndex, cache, \"row\");\n    var maxOffset = scrollTop + height;\n    var offset = item.size + item.offset;\n    var stopIndex = startIndex;\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, cache, \"row\").size;\n    }\n    return stopIndex;\n  },\n  injectToInstance: function injectToInstance(instance, cache) {\n    var resetAfter = function resetAfter(_ref8, forceUpdate) {\n      var columnIndex = _ref8.columnIndex,\n        rowIndex = _ref8.rowIndex;\n      var _a, _b;\n      forceUpdate = isUndefined(forceUpdate) ? true : forceUpdate;\n      if (isNumber(columnIndex)) {\n        cache.value.lastVisitedColumnIndex = Math.min(cache.value.lastVisitedColumnIndex, columnIndex - 1);\n      }\n      if (isNumber(rowIndex)) {\n        cache.value.lastVisitedRowIndex = Math.min(cache.value.lastVisitedRowIndex, rowIndex - 1);\n      }\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache.value(-1, null, null);\n      if (forceUpdate) (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n    };\n    var resetAfterColumnIndex = function resetAfterColumnIndex(columnIndex, forceUpdate) {\n      resetAfter({\n        columnIndex: columnIndex\n      }, forceUpdate);\n    };\n    var resetAfterRowIndex = function resetAfterRowIndex(rowIndex, forceUpdate) {\n      resetAfter({\n        rowIndex: rowIndex\n      }, forceUpdate);\n    };\n    Object.assign(instance.proxy, {\n      resetAfterColumnIndex: resetAfterColumnIndex,\n      resetAfterRowIndex: resetAfterRowIndex,\n      resetAfter: resetAfter\n    });\n  },\n  initCache: function initCache(_ref9) {\n    var _ref9$estimatedColumn = _ref9.estimatedColumnWidth,\n      estimatedColumnWidth = _ref9$estimatedColumn === void 0 ? DEFAULT_DYNAMIC_LIST_ITEM_SIZE : _ref9$estimatedColumn,\n      _ref9$estimatedRowHei = _ref9.estimatedRowHeight,\n      estimatedRowHeight = _ref9$estimatedRowHei === void 0 ? DEFAULT_DYNAMIC_LIST_ITEM_SIZE : _ref9$estimatedRowHei;\n    var cache = {\n      column: {},\n      estimatedColumnWidth: estimatedColumnWidth,\n      estimatedRowHeight: estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: function validateProps(_ref10) {\n    var columnWidth = _ref10.columnWidth,\n      rowHeight = _ref10.rowHeight;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE, \"\\n          \\\"columnWidth\\\" must be passed as function,\\n            instead \".concat(_typeof(columnWidth), \" was given.\\n        \"));\n      }\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE, \"\\n          \\\"rowHeight\\\" must be passed as function,\\n            instead \".concat(_typeof(rowHeight), \" was given.\\n        \"));\n      }\n    }\n  }\n});\nexport { DynamicSizeGrid as default };","map":{"version":3,"names":["max","Math","min","floor","SCOPE","ACCESS_SIZER_KEY_MAP","column","row","ACCESS_LAST_VISITED_KEY_MAP","getItemFromCache","props","index","gridCache","type","_ref","cachedItems","sizer","lastVisited","offset","item","size","i","bs","low","high","mid","currentOffset","es","idx","total","totalColumn","totalRow","exponent","findItem","_ref2","cache","lastVisitedIndex","lastVisitedItemOffset","getEstimatedTotalHeight","_ref3","_ref4","estimatedRowHeight","lastVisitedRowIndex","sizeOfVisitedRows","unvisitedItems","sizeOfUnvisitedItems","getEstimatedTotalWidth","_ref5","_ref6","estimatedColumnWidth","lastVisitedColumnIndex","sizeOfVisitedColumns","ACCESS_ESTIMATED_SIZE_KEY_MAP","getOffset","alignment","scrollOffset","scrollBarWidth","_ref7","height","width","estimatedSizeAssociates","estimatedSize","maxOffset","minOffset","SMART_ALIGNMENT","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","round","DynamicSizeGrid","createGrid","name","getColumnPosition","getRowPosition","getColumnOffset","columnIndex","scrollLeft","getRowOffset","rowIndex","scrollTop","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","startIndex","stopIndex","getRowStartIndexForOffset","getRowStopIndexForStartIndex","injectToInstance","instance","resetAfter","_ref8","forceUpdate","_a","_b","isUndefined","isNumber","value","exposed","getItemStyleCache","proxy","$forceUpdate","resetAfterColumnIndex","resetAfterRowIndex","Object","assign","initCache","_ref9","_ref9$estimatedColumn","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","_ref9$estimatedRowHei","clearCache","validateProps","_ref10","columnWidth","rowHeight","process","env","NODE_ENV","isFunction","throwError","concat","_typeof"],"sources":["../../../../../../../packages/components/virtual-list/src/components/dynamic-size-grid.ts"],"sourcesContent":["// @ts-nocheck\nimport {\n  isFunction,\n  isNumber,\n  isUndefined,\n  throwError,\n} from '@element-plus/utils'\nimport createGrid from '../builders/build-grid'\n\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\nimport type { GridInstance } from '../builders/build-grid'\nimport type { VirtualizedGridProps } from '../props'\n\nimport type { Alignment, GridCache, ItemSize, ListItem } from '../types'\n\nconst { max, min, floor } = Math\nconst SCOPE = 'ElDynamicSizeGrid'\n\ntype Props = VirtualizedGridProps\ntype CacheItemType = 'column' | 'row'\ntype Indices = {\n  columnIndex?: number\n  rowIndex?: number\n}\n\n// generates props access key via type\nconst ACCESS_SIZER_KEY_MAP = {\n  column: 'columnWidth',\n  row: 'rowHeight',\n}\n\n// generates cache access key via type\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: 'lastVisitedColumnIndex',\n  row: 'lastVisitedRowIndex',\n}\n\nconst getItemFromCache = (\n  props: Props,\n  index: number,\n  gridCache: GridCache,\n  type: CacheItemType\n) => {\n  const [cachedItems, sizer, lastVisited] = [\n    gridCache[type],\n    props[ACCESS_SIZER_KEY_MAP[type]],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]],\n  ] as [Record<string, ListItem>, ItemSize, number]\n\n  if (index > lastVisited) {\n    let offset = 0\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited]\n      offset = item.offset + item.size\n    }\n\n    for (let i = lastVisited + 1; i <= index; i++) {\n      // console.log(i, sizer(i))\n      const size = sizer(i)\n\n      cachedItems[i] = {\n        offset,\n        size,\n      }\n\n      offset += size\n    }\n\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index\n  }\n\n  return cachedItems[index]\n}\n\nconst bs = (\n  props: Props,\n  gridCache: GridCache,\n  low: number,\n  high: number,\n  offset: number,\n  type: CacheItemType\n) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2)\n    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset\n\n    if (currentOffset === offset) {\n      return mid\n    } else if (currentOffset < offset) {\n      low = mid + 1\n    } else {\n      high = mid - 1\n    }\n  }\n\n  return max(0, low - 1)\n}\n\nconst es = (\n  props: Props,\n  gridCache: GridCache,\n  idx: number,\n  offset: number,\n  type: CacheItemType\n) => {\n  const total = type === 'column' ? props.totalColumn : props.totalRow\n  let exponent = 1\n\n  while (\n    idx < total &&\n    getItemFromCache(props, idx, gridCache, type).offset < offset\n  ) {\n    idx += exponent\n    exponent *= 2\n  }\n\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type)\n}\n\nconst findItem = (\n  props: Props,\n  gridCache: GridCache,\n  offset: number,\n  type: CacheItemType\n) => {\n  const [cache, lastVisitedIndex] = [\n    gridCache[type],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]],\n  ] as [Record<string, ListItem>, number]\n\n  const lastVisitedItemOffset =\n    lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0\n\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type)\n  }\n\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type)\n}\n\nconst getEstimatedTotalHeight = (\n  { totalRow }: Props,\n  { estimatedRowHeight, lastVisitedRowIndex, row }: GridCache\n) => {\n  let sizeOfVisitedRows = 0\n\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1\n  }\n\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex]\n    sizeOfVisitedRows = item.offset + item.size\n  }\n\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight\n\n  return sizeOfVisitedRows + sizeOfUnvisitedItems\n}\nconst getEstimatedTotalWidth = (\n  { totalColumn }: Props,\n  { column, estimatedColumnWidth, lastVisitedColumnIndex }: GridCache\n) => {\n  let sizeOfVisitedColumns = 0\n\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1\n  }\n\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex]\n    sizeOfVisitedColumns = item.offset + item.size\n  }\n\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth\n\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems\n}\n\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight,\n}\n\nconst getOffset = (\n  props: Props,\n  index: number,\n  alignment: Alignment,\n  scrollOffset: number,\n  cache: GridCache,\n  type: CacheItemType,\n  scrollBarWidth: number\n) => {\n  const [size, estimatedSizeAssociates] = [\n    type === 'row' ? props.height : props.width,\n    ACCESS_ESTIMATED_SIZE_KEY_MAP[type],\n  ] as [number, (props: Props, cache: GridCache) => number]\n  const item = getItemFromCache(props, index, cache, type)\n\n  const estimatedSize = estimatedSizeAssociates(props, cache)\n\n  const maxOffset = max(0, min(estimatedSize - size, item.offset))\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size)\n\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT\n    } else {\n      alignment = CENTERED_ALIGNMENT\n    }\n  }\n\n  switch (alignment) {\n    case START_ALIGNMENT: {\n      return maxOffset\n    }\n    case END_ALIGNMENT: {\n      return minOffset\n    }\n    case CENTERED_ALIGNMENT: {\n      return Math.round(minOffset + (maxOffset - minOffset) / 2)\n    }\n    case AUTO_ALIGNMENT:\n    default: {\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset\n      } else if (minOffset > maxOffset) {\n        return minOffset\n      } else if (scrollOffset < minOffset) {\n        return minOffset\n      } else {\n        return maxOffset\n      }\n    }\n  }\n}\n\nconst DynamicSizeGrid = createGrid({\n  name: 'ElDynamicSizeGrid',\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, 'column')\n    return [item.size, item.offset]\n  },\n\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, 'row')\n    return [item.size, item.offset]\n  },\n\n  getColumnOffset: (\n    props,\n    columnIndex,\n    alignment,\n    scrollLeft,\n    cache,\n    scrollBarWidth\n  ) =>\n    getOffset(\n      props,\n      columnIndex,\n      alignment,\n      scrollLeft,\n      cache,\n      'column',\n      scrollBarWidth\n    ),\n\n  getRowOffset: (\n    props,\n    rowIndex,\n    alignment,\n    scrollTop,\n    cache,\n    scrollBarWidth: number\n  ) =>\n    getOffset(\n      props,\n      rowIndex,\n      alignment,\n      scrollTop,\n      cache,\n      'row',\n      scrollBarWidth\n    ),\n\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) =>\n    findItem(props, cache, scrollLeft, 'column'),\n\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache(props, startIndex, cache, 'column')\n\n    const maxOffset = scrollLeft + (props.width as number)\n\n    let offset = item.offset + item.size\n    let stopIndex = startIndex\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, startIndex, cache, 'column').size\n    }\n    return stopIndex\n  },\n\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n\n  getRowStartIndexForOffset: (props, scrollTop, cache) =>\n    findItem(props, cache, scrollTop, 'row'),\n\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const { totalRow, height } = props\n    const item = getItemFromCache(props, startIndex, cache, 'row')\n    const maxOffset = scrollTop + (height as number)\n\n    let offset = item.size + item.offset\n    let stopIndex = startIndex\n\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, stopIndex, cache, 'row').size\n    }\n\n    return stopIndex\n  },\n  injectToInstance: (instance, cache) => {\n    const resetAfter = (\n      { columnIndex, rowIndex }: Indices,\n      forceUpdate?: boolean\n    ) => {\n      forceUpdate = isUndefined(forceUpdate) ? true : forceUpdate\n\n      if (isNumber(columnIndex)) {\n        cache.value.lastVisitedColumnIndex = Math.min(\n          cache.value.lastVisitedColumnIndex,\n          columnIndex - 1\n        )\n      }\n\n      if (isNumber(rowIndex)) {\n        // console.log(rowIndex)\n        cache.value.lastVisitedRowIndex = Math.min(\n          cache.value.lastVisitedRowIndex,\n          rowIndex - 1\n        )\n      }\n\n      instance.exposed?.getItemStyleCache.value(-1, null, null)\n\n      if (forceUpdate) instance.proxy?.$forceUpdate()\n    }\n\n    const resetAfterColumnIndex = (\n      columnIndex: number,\n      forceUpdate: boolean\n    ) => {\n      resetAfter(\n        {\n          columnIndex,\n        },\n        forceUpdate\n      )\n    }\n\n    const resetAfterRowIndex = (rowIndex: number, forceUpdate: boolean) => {\n      resetAfter(\n        {\n          rowIndex,\n        },\n        forceUpdate\n      )\n    }\n\n    Object.assign(instance.proxy, {\n      resetAfterColumnIndex,\n      resetAfterRowIndex,\n      resetAfter,\n    })\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {},\n    } as GridCache\n\n    // TODO: expose methods.\n    return cache\n  },\n\n  clearCache: false,\n\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isFunction(columnWidth)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `\n        )\n      }\n\n      if (!isFunction(rowHeight)) {\n        throwError(\n          SCOPE,\n          `\n          \"rowHeight\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default DynamicSizeGrid\n\nexport type ResetAfterIndex = (idx: number, forceUpdate: boolean) => void\nexport type ResetAfterIndices = (indices: Indices, forceUpdate: boolean) => void\n\nexport type DynamicSizeGridInstance = GridInstance & {\n  resetAfterColumnIndex: ResetAfterIndex\n  resetAfterRowIndex: ResetAfterIndex\n  resetAfter: ResetAfterIndices\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}