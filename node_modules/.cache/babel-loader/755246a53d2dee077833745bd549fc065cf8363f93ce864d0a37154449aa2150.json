{"ast":null,"code":"import _objectSpread from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { defineComponent, ref, computed, onMounted, watch, provide, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, createCommentVNode, createElementVNode, renderSlot } from 'vue';\nimport { useEventListener } from '@vueuse/core';\nimport { anchorProps, anchorEmits } from './anchor.mjs';\nimport { anchorKey } from './constants.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { getElement } from '../../../utils/dom/element.mjs';\nimport { throttleByRaf } from '../../../utils/throttleByRaf.mjs';\nimport { isWindow, isUndefined } from '../../../utils/types.mjs';\nimport { getScrollElement, animateScrollTo, getScrollTop } from '../../../utils/dom/scroll.mjs';\nimport { getOffsetTopDistance } from '../../../utils/dom/position.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nvar __default__ = defineComponent({\n  name: \"ElAnchor\"\n});\nvar _sfc_main = /* @__PURE__ */defineComponent(_objectSpread(_objectSpread({}, __default__), {}, {\n  props: anchorProps,\n  emits: anchorEmits,\n  setup: function setup(__props, _ref) {\n    var expose = _ref.expose,\n      emit = _ref.emit;\n    var props = __props;\n    var currentAnchor = ref(\"\");\n    var anchorRef = ref(null);\n    var markerRef = ref(null);\n    var containerEl = ref();\n    var links = {};\n    var isScrolling = false;\n    var currentScrollTop = 0;\n    var ns = useNamespace(\"anchor\");\n    var cls = computed(function () {\n      return [ns.b(), props.type === \"underline\" ? ns.m(\"underline\") : \"\", ns.m(props.direction)];\n    });\n    var addLink = function addLink(state) {\n      links[state.href] = state.el;\n    };\n    var removeLink = function removeLink(href) {\n      delete links[href];\n    };\n    var setCurrentAnchor = function setCurrentAnchor(href) {\n      var activeHref = currentAnchor.value;\n      if (activeHref !== href) {\n        currentAnchor.value = href;\n        emit(\"change\", href);\n      }\n    };\n    var clearAnimate = null;\n    var scrollToAnchor = function scrollToAnchor(href) {\n      if (!containerEl.value) return;\n      var target = getElement(href);\n      if (!target) return;\n      if (clearAnimate) clearAnimate();\n      isScrolling = true;\n      var scrollEle = getScrollElement(target, containerEl.value);\n      var distance = getOffsetTopDistance(target, scrollEle);\n      var max = scrollEle.scrollHeight - scrollEle.clientHeight;\n      var to = Math.min(distance - props.offset, max);\n      clearAnimate = animateScrollTo(containerEl.value, currentScrollTop, to, props.duration, function () {\n        setTimeout(function () {\n          isScrolling = false;\n        }, 20);\n      });\n    };\n    var scrollTo = function scrollTo(href) {\n      if (href) {\n        setCurrentAnchor(href);\n        scrollToAnchor(href);\n      }\n    };\n    var handleClick = function handleClick(e, href) {\n      emit(\"click\", e, href);\n      scrollTo(href);\n    };\n    var handleScroll = throttleByRaf(function () {\n      if (containerEl.value) {\n        currentScrollTop = getScrollTop(containerEl.value);\n      }\n      var currentHref = getCurrentHref();\n      if (isScrolling || isUndefined(currentHref)) return;\n      setCurrentAnchor(currentHref);\n    });\n    var getCurrentHref = function getCurrentHref() {\n      if (!containerEl.value) return;\n      var scrollTop = getScrollTop(containerEl.value);\n      var anchorTopList = [];\n      for (var _i = 0, _Object$keys = Object.keys(links); _i < _Object$keys.length; _i++) {\n        var href = _Object$keys[_i];\n        var target = getElement(href);\n        if (!target) continue;\n        var scrollEle = getScrollElement(target, containerEl.value);\n        var distance = getOffsetTopDistance(target, scrollEle);\n        anchorTopList.push({\n          top: distance - props.offset - props.bound,\n          href: href\n        });\n      }\n      anchorTopList.sort(function (prev, next) {\n        return prev.top - next.top;\n      });\n      for (var i = 0; i < anchorTopList.length; i++) {\n        var item = anchorTopList[i];\n        var next = anchorTopList[i + 1];\n        if (i === 0 && scrollTop === 0) {\n          return props.selectScrollTop ? item.href : \"\";\n        }\n        if (item.top <= scrollTop && (!next || next.top > scrollTop)) {\n          return item.href;\n        }\n      }\n    };\n    var getContainer = function getContainer() {\n      var el = getElement(props.container);\n      if (!el || isWindow(el)) {\n        containerEl.value = window;\n      } else {\n        containerEl.value = el;\n      }\n    };\n    useEventListener(containerEl, \"scroll\", handleScroll);\n    var markerStyle = computed(function () {\n      if (!anchorRef.value || !markerRef.value || !currentAnchor.value) return {};\n      var currentLinkEl = links[currentAnchor.value];\n      if (!currentLinkEl) return {};\n      var anchorRect = anchorRef.value.getBoundingClientRect();\n      var markerRect = markerRef.value.getBoundingClientRect();\n      var linkRect = currentLinkEl.getBoundingClientRect();\n      if (props.direction === \"horizontal\") {\n        var left = linkRect.left - anchorRect.left;\n        return {\n          left: \"\".concat(left, \"px\"),\n          width: \"\".concat(linkRect.width, \"px\"),\n          opacity: 1\n        };\n      } else {\n        var top = linkRect.top - anchorRect.top + (linkRect.height - markerRect.height) / 2;\n        return {\n          top: \"\".concat(top, \"px\"),\n          opacity: 1\n        };\n      }\n    });\n    onMounted(function () {\n      getContainer();\n      var hash = decodeURIComponent(window.location.hash);\n      var target = getElement(hash);\n      if (target) {\n        scrollTo(hash);\n      } else {\n        handleScroll();\n      }\n    });\n    watch(function () {\n      return props.container;\n    }, function () {\n      getContainer();\n    });\n    provide(anchorKey, {\n      ns: ns,\n      direction: props.direction,\n      currentAnchor: currentAnchor,\n      addLink: addLink,\n      removeLink: removeLink,\n      handleClick: handleClick\n    });\n    expose({\n      scrollTo: scrollTo\n    });\n    return function (_ctx, _cache) {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"anchorRef\",\n        ref: anchorRef,\n        \"class\": normalizeClass(unref(cls))\n      }, [_ctx.marker ? (openBlock(), createElementBlock(\"div\", {\n        key: 0,\n        ref_key: \"markerRef\",\n        ref: markerRef,\n        \"class\": normalizeClass(unref(ns).e(\"marker\")),\n        style: normalizeStyle(unref(markerStyle))\n      }, null, 6)) : createCommentVNode(\"v-if\", true), createElementVNode(\"div\", {\n        \"class\": normalizeClass(unref(ns).e(\"list\"))\n      }, [renderSlot(_ctx.$slots, \"default\")], 2)], 2);\n    };\n  }\n}));\nvar Anchor = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"anchor.vue\"]]);\nexport { Anchor as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}