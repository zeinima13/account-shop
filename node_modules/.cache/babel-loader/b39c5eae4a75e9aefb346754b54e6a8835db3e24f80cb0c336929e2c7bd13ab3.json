{"ast":null,"code":"import _toConsumableArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { reactive } from 'vue';\nimport { markNodeData, NODE_KEY } from './util.mjs';\nimport { hasOwn, isArray, isFunction, isString } from '@vue/shared';\nimport { isBoolean, isUndefined } from '../../../../utils/types.mjs';\nvar getChildState = function getChildState(node) {\n  var all = true;\n  var none = true;\n  var allWithoutDisable = true;\n  for (var i = 0, j = node.length; i < j; i++) {\n    var n = node[i];\n    if (n.checked !== true || n.indeterminate) {\n      all = false;\n      if (!n.disabled) {\n        allWithoutDisable = false;\n      }\n    }\n    if (n.checked !== false || n.indeterminate) {\n      none = false;\n    }\n  }\n  return {\n    all: all,\n    none: none,\n    allWithoutDisable: allWithoutDisable,\n    half: !all && !none\n  };\n};\nvar _reInitChecked = function reInitChecked(node) {\n  if (node.childNodes.length === 0 || node.loading) return;\n  var _getChildState = getChildState(node.childNodes),\n    all = _getChildState.all,\n    none = _getChildState.none,\n    half = _getChildState.half;\n  if (all) {\n    node.checked = true;\n    node.indeterminate = false;\n  } else if (half) {\n    node.checked = false;\n    node.indeterminate = true;\n  } else if (none) {\n    node.checked = false;\n    node.indeterminate = false;\n  }\n  var parent = node.parent;\n  if (!parent || parent.level === 0) return;\n  if (!node.store.checkStrictly) {\n    _reInitChecked(parent);\n  }\n};\nvar getPropertyFromData = function getPropertyFromData(node, prop) {\n  var props = node.store.props;\n  var data = node.data || {};\n  var config = props[prop];\n  if (isFunction(config)) {\n    return config(data, node);\n  } else if (isString(config)) {\n    return data[config];\n  } else if (isUndefined(config)) {\n    var dataProp = data[prop];\n    return dataProp === void 0 ? \"\" : dataProp;\n  }\n};\nvar nodeIdSeed = 0;\nvar Node = /*#__PURE__*/function () {\n  function Node(options) {\n    _classCallCheck(this, Node);\n    this.id = nodeIdSeed++;\n    this.text = null;\n    this.checked = false;\n    this.indeterminate = false;\n    this.data = null;\n    this.expanded = false;\n    this.parent = null;\n    this.visible = true;\n    this.isCurrent = false;\n    this.canFocus = false;\n    for (var name in options) {\n      if (hasOwn(options, name)) {\n        this[name] = options[name];\n      }\n    }\n    this.level = 0;\n    this.loaded = false;\n    this.childNodes = [];\n    this.loading = false;\n    if (this.parent) {\n      this.level = this.parent.level + 1;\n    }\n  }\n  return _createClass(Node, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var store = this.store;\n      if (!store) {\n        throw new Error(\"[Node]store is required!\");\n      }\n      store.registerNode(this);\n      var props = store.props;\n      if (props && typeof props.isLeaf !== \"undefined\") {\n        var isLeaf = getPropertyFromData(this, \"isLeaf\");\n        if (isBoolean(isLeaf)) {\n          this.isLeafByUser = isLeaf;\n        }\n      }\n      if (store.lazy !== true && this.data) {\n        this.setData(this.data);\n        if (store.defaultExpandAll) {\n          this.expanded = true;\n          this.canFocus = true;\n        }\n      } else if (this.level > 0 && store.lazy && store.defaultExpandAll && !this.isLeafByUser) {\n        this.expand();\n      }\n      if (!isArray(this.data)) {\n        markNodeData(this, this.data);\n      }\n      if (!this.data) return;\n      var defaultExpandedKeys = store.defaultExpandedKeys;\n      var key = store.key;\n      if (key && defaultExpandedKeys && defaultExpandedKeys.includes(this.key)) {\n        this.expand(null, store.autoExpandParent);\n      }\n      if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {\n        store.currentNode = this;\n        store.currentNode.isCurrent = true;\n      }\n      if (store.lazy) {\n        store._initDefaultCheckedNode(this);\n      }\n      this.updateLeafState();\n      if (this.parent && (this.level === 1 || this.parent.expanded === true)) this.canFocus = true;\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      if (!isArray(data)) {\n        markNodeData(this, data);\n      }\n      this.data = data;\n      this.childNodes = [];\n      var children;\n      if (this.level === 0 && isArray(this.data)) {\n        children = this.data;\n      } else {\n        children = getPropertyFromData(this, \"children\") || [];\n      }\n      for (var i = 0, j = children.length; i < j; i++) {\n        this.insertChild({\n          data: children[i]\n        });\n      }\n    }\n  }, {\n    key: \"label\",\n    get: function get() {\n      return getPropertyFromData(this, \"label\");\n    }\n  }, {\n    key: \"key\",\n    get: function get() {\n      var nodeKey = this.store.key;\n      if (this.data) return this.data[nodeKey];\n      return null;\n    }\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return getPropertyFromData(this, \"disabled\");\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      var parent = this.parent;\n      if (parent) {\n        var index = parent.childNodes.indexOf(this);\n        if (index > -1) {\n          return parent.childNodes[index + 1];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      var parent = this.parent;\n      if (parent) {\n        var index = parent.childNodes.indexOf(this);\n        if (index > -1) {\n          return index > 0 ? parent.childNodes[index - 1] : null;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(target) {\n      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return (this.childNodes || []).some(function (child) {\n        return child === target || deep && child.contains(target);\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var parent = this.parent;\n      if (parent) {\n        parent.removeChild(this);\n      }\n    }\n  }, {\n    key: \"insertChild\",\n    value: function insertChild(child, index, batch) {\n      if (!child) throw new Error(\"InsertChild error: child is required.\");\n      if (!(child instanceof Node)) {\n        if (!batch) {\n          var children = this.getChildren(true);\n          if (!children.includes(child.data)) {\n            if (isUndefined(index) || index < 0) {\n              children.push(child.data);\n            } else {\n              children.splice(index, 0, child.data);\n            }\n          }\n        }\n        Object.assign(child, {\n          parent: this,\n          store: this.store\n        });\n        child = reactive(new Node(child));\n        if (child instanceof Node) {\n          child.initialize();\n        }\n      }\n      child.level = this.level + 1;\n      if (isUndefined(index) || index < 0) {\n        this.childNodes.push(child);\n      } else {\n        this.childNodes.splice(index, 0, child);\n      }\n      this.updateLeafState();\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(child, ref) {\n      var index;\n      if (ref) {\n        index = this.childNodes.indexOf(ref);\n      }\n      this.insertChild(child, index);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(child, ref) {\n      var index;\n      if (ref) {\n        index = this.childNodes.indexOf(ref);\n        if (index !== -1) index += 1;\n      }\n      this.insertChild(child, index);\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      var children = this.getChildren() || [];\n      var dataIndex = children.indexOf(child.data);\n      if (dataIndex > -1) {\n        children.splice(dataIndex, 1);\n      }\n      var index = this.childNodes.indexOf(child);\n      if (index > -1) {\n        this.store && this.store.deregisterNode(child);\n        child.parent = null;\n        this.childNodes.splice(index, 1);\n      }\n      this.updateLeafState();\n    }\n  }, {\n    key: \"removeChildByData\",\n    value: function removeChildByData(data) {\n      var targetNode = null;\n      for (var i = 0; i < this.childNodes.length; i++) {\n        if (this.childNodes[i].data === data) {\n          targetNode = this.childNodes[i];\n          break;\n        }\n      }\n      if (targetNode) {\n        this.removeChild(targetNode);\n      }\n    }\n  }, {\n    key: \"expand\",\n    value: function expand(callback, expandParent) {\n      var _this = this;\n      var done = function done() {\n        if (expandParent) {\n          var parent = _this.parent;\n          while (parent.level > 0) {\n            parent.expanded = true;\n            parent = parent.parent;\n          }\n        }\n        _this.expanded = true;\n        if (callback) callback();\n        _this.childNodes.forEach(function (item) {\n          item.canFocus = true;\n        });\n      };\n      if (this.shouldLoadData()) {\n        this.loadData(function (data) {\n          if (isArray(data)) {\n            if (_this.checked) {\n              _this.setChecked(true, true);\n            } else if (!_this.store.checkStrictly) {\n              _reInitChecked(_this);\n            }\n            done();\n          }\n        });\n      } else {\n        done();\n      }\n    }\n  }, {\n    key: \"doCreateChildren\",\n    value: function doCreateChildren(array) {\n      var _this2 = this;\n      var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      array.forEach(function (item) {\n        _this2.insertChild(Object.assign({\n          data: item\n        }, defaultProps), void 0, true);\n      });\n    }\n  }, {\n    key: \"collapse\",\n    value: function collapse() {\n      this.expanded = false;\n      this.childNodes.forEach(function (item) {\n        item.canFocus = false;\n      });\n    }\n  }, {\n    key: \"shouldLoadData\",\n    value: function shouldLoadData() {\n      return this.store.lazy === true && this.store.load && !this.loaded;\n    }\n  }, {\n    key: \"updateLeafState\",\n    value: function updateLeafState() {\n      if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== \"undefined\") {\n        this.isLeaf = this.isLeafByUser;\n        return;\n      }\n      var childNodes = this.childNodes;\n      if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {\n        this.isLeaf = !childNodes || childNodes.length === 0;\n        return;\n      }\n      this.isLeaf = false;\n    }\n  }, {\n    key: \"setChecked\",\n    value: function setChecked(value, deep, recursion, passValue) {\n      var _this3 = this;\n      this.indeterminate = value === \"half\";\n      this.checked = value === true;\n      if (this.store.checkStrictly) return;\n      if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n        var _getChildState2 = getChildState(this.childNodes),\n          all = _getChildState2.all,\n          allWithoutDisable = _getChildState2.allWithoutDisable;\n        if (!this.isLeaf && !all && allWithoutDisable) {\n          this.checked = false;\n          value = false;\n        }\n        var handleDescendants = function handleDescendants() {\n          if (deep) {\n            var childNodes = _this3.childNodes;\n            for (var i = 0, j = childNodes.length; i < j; i++) {\n              var child = childNodes[i];\n              passValue = passValue || value !== false;\n              var isCheck = child.disabled ? child.checked : passValue;\n              child.setChecked(isCheck, deep, true, passValue);\n            }\n            var _getChildState3 = getChildState(childNodes),\n              half = _getChildState3.half,\n              all2 = _getChildState3.all;\n            if (!all2) {\n              _this3.checked = all2;\n              _this3.indeterminate = half;\n            }\n          }\n        };\n        if (this.shouldLoadData()) {\n          this.loadData(function () {\n            handleDescendants();\n            _reInitChecked(_this3);\n          }, {\n            checked: value !== false\n          });\n          return;\n        } else {\n          handleDescendants();\n        }\n      }\n      var parent = this.parent;\n      if (!parent || parent.level === 0) return;\n      if (!recursion) {\n        _reInitChecked(parent);\n      }\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      var forceInit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.level === 0) return this.data;\n      var data = this.data;\n      if (!data) return null;\n      var props = this.store.props;\n      var children = \"children\";\n      if (props) {\n        children = props.children || \"children\";\n      }\n      if (data[children] === void 0) {\n        data[children] = null;\n      }\n      if (forceInit && !data[children]) {\n        data[children] = [];\n      }\n      return data[children];\n    }\n  }, {\n    key: \"updateChildren\",\n    value: function updateChildren() {\n      var _this4 = this;\n      var newData = this.getChildren() || [];\n      var oldData = this.childNodes.map(function (node) {\n        return node.data;\n      });\n      var newDataMap = {};\n      var newNodes = [];\n      newData.forEach(function (item, index) {\n        var key = item[NODE_KEY];\n        var isNodeExists = !!key && oldData.findIndex(function (data) {\n          return data[NODE_KEY] === key;\n        }) >= 0;\n        if (isNodeExists) {\n          newDataMap[key] = {\n            index: index,\n            data: item\n          };\n        } else {\n          newNodes.push({\n            index: index,\n            data: item\n          });\n        }\n      });\n      if (!this.store.lazy) {\n        oldData.forEach(function (item) {\n          if (!newDataMap[item[NODE_KEY]]) _this4.removeChildByData(item);\n        });\n      }\n      newNodes.forEach(function (_ref) {\n        var index = _ref.index,\n          data = _ref.data;\n        _this4.insertChild({\n          data: data\n        }, index);\n      });\n      this.updateLeafState();\n    }\n  }, {\n    key: \"loadData\",\n    value: function loadData(callback) {\n      var _this5 = this;\n      var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {\n        this.loading = true;\n        var resolve = function resolve(children) {\n          _this5.childNodes = [];\n          _this5.doCreateChildren(children, defaultProps);\n          _this5.loaded = true;\n          _this5.loading = false;\n          _this5.updateLeafState();\n          if (callback) {\n            callback.call(_this5, children);\n          }\n        };\n        var reject = function reject() {\n          _this5.loading = false;\n        };\n        this.store.load(this, resolve, reject);\n      } else {\n        if (callback) {\n          callback.call(this);\n        }\n      }\n    }\n  }, {\n    key: \"eachNode\",\n    value: function eachNode(callback) {\n      var arr = [this];\n      while (arr.length) {\n        var node = arr.shift();\n        arr.unshift.apply(arr, _toConsumableArray(node.childNodes));\n        callback(node);\n      }\n    }\n  }, {\n    key: \"reInitChecked\",\n    value: function reInitChecked() {\n      if (this.store.checkStrictly) return;\n      _reInitChecked(this);\n    }\n  }]);\n}();\nexport { Node as default, getChildState };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}