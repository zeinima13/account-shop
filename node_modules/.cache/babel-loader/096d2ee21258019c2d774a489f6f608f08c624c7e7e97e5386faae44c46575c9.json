{"ast":null,"code":"import _objectSpread from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.number.is-nan.js\";\nimport \"core-js/modules/es.number.parse-int.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { createVNode, render } from 'vue';\nimport { merge, get, flatMap, isNull } from 'lodash-unified';\nimport { ElTooltip } from '../../tooltip/index.mjs';\nimport { isArray, isString, isFunction, hasOwn, isObject } from '@vue/shared';\nimport { throwError } from '../../../utils/error.mjs';\nimport { isUndefined, isNumber, isBoolean } from '../../../utils/types.mjs';\nvar getCell = function getCell(event) {\n  var _a;\n  return (_a = event.target) == null ? void 0 : _a.closest(\"td\");\n};\nvar orderBy = function orderBy(array, sortKey, reverse, sortMethod, sortBy) {\n  if (!sortKey && !sortMethod && (!sortBy || isArray(sortBy) && !sortBy.length)) {\n    return array;\n  }\n  if (isString(reverse)) {\n    reverse = reverse === \"descending\" ? -1 : 1;\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1;\n  }\n  var getKey = sortMethod ? null : function (value, index) {\n    if (sortBy) {\n      if (!isArray(sortBy)) {\n        sortBy = [sortBy];\n      }\n      return sortBy.map(function (by) {\n        if (isString(by)) {\n          return get(value, by);\n        } else {\n          return by(value, index, array);\n        }\n      });\n    }\n    if (sortKey !== \"$key\") {\n      if (isObject(value) && \"$value\" in value) value = value.$value;\n    }\n    return [isObject(value) ? get(value, sortKey) : value];\n  };\n  var compare = function compare(a, b) {\n    if (sortMethod) {\n      return sortMethod(a.value, b.value);\n    }\n    for (var i = 0, len = a.key.length; i < len; i++) {\n      if (a.key[i] < b.key[i]) {\n        return -1;\n      }\n      if (a.key[i] > b.key[i]) {\n        return 1;\n      }\n    }\n    return 0;\n  };\n  return array.map(function (value, index) {\n    return {\n      value: value,\n      index: index,\n      key: getKey ? getKey(value, index) : null\n    };\n  }).sort(function (a, b) {\n    var order = compare(a, b);\n    if (!order) {\n      order = a.index - b.index;\n    }\n    return order * +reverse;\n  }).map(function (item) {\n    return item.value;\n  });\n};\nvar getColumnById = function getColumnById(table, columnId) {\n  var column = null;\n  table.columns.forEach(function (item) {\n    if (item.id === columnId) {\n      column = item;\n    }\n  });\n  return column;\n};\nvar getColumnByKey = function getColumnByKey(table, columnKey) {\n  var column = null;\n  for (var i = 0; i < table.columns.length; i++) {\n    var item = table.columns[i];\n    if (item.columnKey === columnKey) {\n      column = item;\n      break;\n    }\n  }\n  if (!column) throwError(\"ElTable\", \"No column matching with column-key: \".concat(columnKey));\n  return column;\n};\nvar getColumnByCell = function getColumnByCell(table, cell, namespace) {\n  var matches = (cell.className || \"\").match(new RegExp(\"\".concat(namespace, \"-table_[^\\\\s]+\"), \"gm\"));\n  if (matches) {\n    return getColumnById(table, matches[0]);\n  }\n  return null;\n};\nvar getRowIdentity = function getRowIdentity(row, rowKey) {\n  if (!row) throw new Error(\"Row is required when get row identity\");\n  if (isString(rowKey)) {\n    if (!rowKey.includes(\".\")) {\n      return \"\".concat(row[rowKey]);\n    }\n    var key = rowKey.split(\".\");\n    var current = row;\n    var _iterator = _createForOfIteratorHelper(key),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var element = _step.value;\n        current = current[element];\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return \"\".concat(current);\n  } else if (isFunction(rowKey)) {\n    return rowKey.call(null, row);\n  }\n};\nvar getKeysMap = function getKeysMap(array, rowKey) {\n  var arrayMap = {};\n  (array || []).forEach(function (row, index) {\n    arrayMap[getRowIdentity(row, rowKey)] = {\n      row: row,\n      index: index\n    };\n  });\n  return arrayMap;\n};\nfunction mergeOptions(defaults, config) {\n  var options = {};\n  var key;\n  for (key in defaults) {\n    options[key] = defaults[key];\n  }\n  for (key in config) {\n    if (hasOwn(config, key)) {\n      var value = config[key];\n      if (!isUndefined(value)) {\n        options[key] = value;\n      }\n    }\n  }\n  return options;\n}\nfunction parseWidth(width) {\n  if (width === \"\") return width;\n  if (!isUndefined(width)) {\n    width = Number.parseInt(width, 10);\n    if (Number.isNaN(width)) {\n      width = \"\";\n    }\n  }\n  return width;\n}\nfunction parseMinWidth(minWidth) {\n  if (minWidth === \"\") return minWidth;\n  if (!isUndefined(minWidth)) {\n    minWidth = parseWidth(minWidth);\n    if (Number.isNaN(minWidth)) {\n      minWidth = 80;\n    }\n  }\n  return minWidth;\n}\nfunction parseHeight(height) {\n  if (isNumber(height)) {\n    return height;\n  }\n  if (isString(height)) {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return Number.parseInt(height, 10);\n    } else {\n      return height;\n    }\n  }\n  return null;\n}\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\nfunction toggleRowStatus(statusArr, row, newVal, tableTreeProps, selectable, rowIndex) {\n  var _rowIndex = rowIndex != null ? rowIndex : 0;\n  var changed = false;\n  var index = statusArr.indexOf(row);\n  var included = index !== -1;\n  var isRowSelectable = selectable == null ? void 0 : selectable.call(null, row, rowIndex);\n  var toggleStatus = function toggleStatus(type) {\n    if (type === \"add\") {\n      statusArr.push(row);\n    } else {\n      statusArr.splice(index, 1);\n    }\n    changed = true;\n  };\n  var _getChildrenCount = function getChildrenCount(row2) {\n    var count = 0;\n    var children = (tableTreeProps == null ? void 0 : tableTreeProps.children) && row2[tableTreeProps.children];\n    if (children && isArray(children)) {\n      count += children.length;\n      children.forEach(function (item) {\n        count += _getChildrenCount(item);\n      });\n    }\n    return count;\n  };\n  if (!selectable || isRowSelectable) {\n    if (isBoolean(newVal)) {\n      if (newVal && !included) {\n        toggleStatus(\"add\");\n      } else if (!newVal && included) {\n        toggleStatus(\"remove\");\n      }\n    } else {\n      included ? toggleStatus(\"remove\") : toggleStatus(\"add\");\n    }\n  }\n  if (!(tableTreeProps == null ? void 0 : tableTreeProps.checkStrictly) && (tableTreeProps == null ? void 0 : tableTreeProps.children) && isArray(row[tableTreeProps.children])) {\n    row[tableTreeProps.children].forEach(function (item) {\n      toggleRowStatus(statusArr, item, newVal != null ? newVal : !included, tableTreeProps, selectable, _rowIndex + 1);\n      _rowIndex += _getChildrenCount(item) + 1;\n    });\n  }\n  return changed;\n}\nfunction walkTreeNode(root, cb) {\n  var childrenKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"children\";\n  var lazyKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"hasChildren\";\n  var isNil = function isNil(array) {\n    return !(isArray(array) && array.length);\n  };\n  function _walker(parent, children, level) {\n    cb(parent, children, level);\n    children.forEach(function (item) {\n      if (item[lazyKey]) {\n        cb(item, null, level + 1);\n        return;\n      }\n      var children2 = item[childrenKey];\n      if (!isNil(children2)) {\n        _walker(item, children2, level + 1);\n      }\n    });\n  }\n  root.forEach(function (item) {\n    if (item[lazyKey]) {\n      cb(item, null, 0);\n      return;\n    }\n    var children = item[childrenKey];\n    if (!isNil(children)) {\n      _walker(item, children, 0);\n    }\n  });\n}\nvar getTableOverflowTooltipProps = function getTableOverflowTooltipProps(props, content) {\n  return _objectSpread(_objectSpread({\n    content: content\n  }, props), {}, {\n    popperOptions: _objectSpread({\n      strategy: \"fixed\"\n    }, props.popperOptions)\n  });\n};\nvar _removePopper = null;\nfunction createTablePopper(props, popperContent, trigger, table) {\n  if ((_removePopper == null ? void 0 : _removePopper.trigger) === trigger) {\n    merge(_removePopper.vm.component.props, getTableOverflowTooltipProps(props, popperContent));\n    return;\n  }\n  _removePopper == null ? void 0 : _removePopper();\n  var parentNode = table == null ? void 0 : table.refs.tableWrapper;\n  var ns = parentNode == null ? void 0 : parentNode.dataset.prefix;\n  var vm = createVNode(ElTooltip, _objectSpread({\n    virtualTriggering: true,\n    virtualRef: trigger,\n    appendTo: parentNode,\n    placement: \"top\",\n    transition: \"none\",\n    offset: 0,\n    hideAfter: 0\n  }, getTableOverflowTooltipProps(props, popperContent)));\n  vm.appContext = _objectSpread(_objectSpread({}, table.appContext), table);\n  var container = document.createElement(\"div\");\n  render(vm, container);\n  vm.component.exposed.onOpen();\n  var scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(\".\".concat(ns, \"-scrollbar__wrap\"));\n  _removePopper = function removePopper() {\n    render(null, container);\n    scrollContainer == null ? void 0 : scrollContainer.removeEventListener(\"scroll\", _removePopper);\n    _removePopper = null;\n  };\n  _removePopper.trigger = trigger;\n  _removePopper.vm = vm;\n  scrollContainer == null ? void 0 : scrollContainer.addEventListener(\"scroll\", _removePopper);\n}\nfunction getCurrentColumns(column) {\n  if (column.children) {\n    return flatMap(column.children, getCurrentColumns);\n  } else {\n    return [column];\n  }\n}\nfunction getColSpan(colSpan, column) {\n  return colSpan + column.colSpan;\n}\nvar isFixedColumn = function isFixedColumn(index, fixed, store, realColumns) {\n  var start = 0;\n  var after = index;\n  var columns = store.states.columns.value;\n  if (realColumns) {\n    var curColumns = getCurrentColumns(realColumns[index]);\n    var preColumns = columns.slice(0, columns.indexOf(curColumns[0]));\n    start = preColumns.reduce(getColSpan, 0);\n    after = start + curColumns.reduce(getColSpan, 0) - 1;\n  } else {\n    start = index;\n  }\n  var fixedLayout;\n  switch (fixed) {\n    case \"left\":\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      }\n      break;\n    case \"right\":\n      if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n      break;\n    default:\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      } else if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n  }\n  return fixedLayout ? {\n    direction: fixedLayout,\n    start: start,\n    after: after\n  } : {};\n};\nvar getFixedColumnsClass = function getFixedColumnsClass(namespace, index, fixed, store, realColumns) {\n  var offset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var classes = [];\n  var _isFixedColumn = isFixedColumn(index, fixed, store, realColumns),\n    direction = _isFixedColumn.direction,\n    start = _isFixedColumn.start,\n    after = _isFixedColumn.after;\n  if (direction) {\n    var isLeft = direction === \"left\";\n    classes.push(\"\".concat(namespace, \"-fixed-column--\").concat(direction));\n    if (isLeft && after + offset === store.states.fixedLeafColumnsLength.value - 1) {\n      classes.push(\"is-last-column\");\n    } else if (!isLeft && start - offset === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n      classes.push(\"is-first-column\");\n    }\n  }\n  return classes;\n};\nfunction getOffset(offset, column) {\n  return offset + (isNull(column.realWidth) || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);\n}\nvar getFixedColumnOffset = function getFixedColumnOffset(index, fixed, store, realColumns) {\n  var _isFixedColumn2 = isFixedColumn(index, fixed, store, realColumns),\n    direction = _isFixedColumn2.direction,\n    _isFixedColumn2$start = _isFixedColumn2.start,\n    start = _isFixedColumn2$start === void 0 ? 0 : _isFixedColumn2$start,\n    _isFixedColumn2$after = _isFixedColumn2.after,\n    after = _isFixedColumn2$after === void 0 ? 0 : _isFixedColumn2$after;\n  if (!direction) {\n    return;\n  }\n  var styles = {};\n  var isLeft = direction === \"left\";\n  var columns = store.states.columns.value;\n  if (isLeft) {\n    styles.left = columns.slice(0, start).reduce(getOffset, 0);\n  } else {\n    styles.right = columns.slice(after + 1).reverse().reduce(getOffset, 0);\n  }\n  return styles;\n};\nvar ensurePosition = function ensurePosition(style, key) {\n  if (!style) return;\n  if (!Number.isNaN(style[key])) {\n    style[key] = \"\".concat(style[key], \"px\");\n  }\n};\nexport { compose, createTablePopper, ensurePosition, getCell, getColumnByCell, getColumnById, getColumnByKey, getFixedColumnOffset, getFixedColumnsClass, getKeysMap, getRowIdentity, isFixedColumn, mergeOptions, orderBy, parseHeight, parseMinWidth, parseWidth, _removePopper as removePopper, toggleRowStatus, walkTreeNode };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}