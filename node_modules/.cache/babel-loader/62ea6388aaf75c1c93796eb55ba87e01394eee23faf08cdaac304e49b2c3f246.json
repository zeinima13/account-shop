{"ast":null,"code":"import _objectSpread from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { defineComponent, getCurrentInstance, ref, computed, unref, onMounted, onUpdated, onActivated, resolveDynamicComponent, h, Fragment, nextTick } from 'vue';\nimport { useEventListener, isClient } from '@vueuse/core';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport useWheel from '../hooks/use-wheel.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { isHorizontal, getRTLOffsetType, getScrollDir } from '../utils.mjs';\nimport { virtualizedListProps } from '../props.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, HORIZONTAL, RTL, RTL_OFFSET_POS_ASC, RTL_OFFSET_NAG, BACKWARD, FORWARD, AUTO_ALIGNMENT, RTL_OFFSET_POS_DESC } from '../defaults.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { isNumber } from '../../../../utils/types.mjs';\nimport { isString, hasOwn } from '@vue/shared';\nvar createList = function createList(_ref) {\n  var name = _ref.name,\n    getOffset = _ref.getOffset,\n    getItemSize = _ref.getItemSize,\n    getItemOffset = _ref.getItemOffset,\n    getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n    getStartIndexForOffset = _ref.getStartIndexForOffset,\n    getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n    initCache = _ref.initCache,\n    clearCache = _ref.clearCache,\n    validateProps = _ref.validateProps;\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup: function setup(props, _ref2) {\n      var emit = _ref2.emit,\n        expose = _ref2.expose;\n      validateProps(props);\n      var instance = getCurrentInstance();\n      var ns = useNamespace(\"vl\");\n      var dynamicSizeCache = ref(initCache(props, instance));\n      var getItemStyleCache = useCache();\n      var windowRef = ref();\n      var innerRef = ref();\n      var scrollbarRef = ref();\n      var states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn\n      });\n      var itemsToRender = computed(function () {\n        var total = props.total,\n          cache = props.cache;\n        var _unref = unref(states),\n          isScrolling = _unref.isScrolling,\n          scrollDir = _unref.scrollDir,\n          scrollOffset = _unref.scrollOffset;\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n        var startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));\n        var stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));\n        var cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        var cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      var estimatedTotalSize = computed(function () {\n        return getEstimatedTotalSize(props, unref(dynamicSizeCache));\n      });\n      var _isHorizontal = computed(function () {\n        return isHorizontal(props.layout);\n      });\n      var windowStyle = computed(function () {\n        return [_defineProperty(_defineProperty(_defineProperty({\n          position: \"relative\"\n        }, \"overflow-\".concat(_isHorizontal.value ? \"x\" : \"y\"), \"scroll\"), \"WebkitOverflowScrolling\", \"touch\"), \"willChange\", \"transform\"), {\n          direction: props.direction,\n          height: isNumber(props.height) ? \"\".concat(props.height, \"px\") : props.height,\n          width: isNumber(props.width) ? \"\".concat(props.width, \"px\") : props.width\n        }, props.style];\n      });\n      var innerStyle = computed(function () {\n        var size = unref(estimatedTotalSize);\n        var horizontal = unref(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : \"\".concat(size, \"px\"),\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? \"\".concat(size, \"px\") : \"100%\"\n        };\n      });\n      var clientSize = computed(function () {\n        return _isHorizontal.value ? props.width : props.height;\n      });\n      var _useWheel = useWheel({\n          atStartEdge: computed(function () {\n            return states.value.scrollOffset <= 0;\n          }),\n          atEndEdge: computed(function () {\n            return states.value.scrollOffset >= estimatedTotalSize.value;\n          }),\n          layout: computed(function () {\n            return props.layout;\n          })\n        }, function (offset) {\n          var _a, _b;\n          (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n          scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n        }),\n        onWheel = _useWheel.onWheel;\n      useEventListener(windowRef, \"wheel\", onWheel, {\n        passive: false\n      });\n      var emitEvents = function emitEvents() {\n        var total = props.total;\n        if (total > 0) {\n          var _unref2 = unref(itemsToRender),\n            _unref3 = _slicedToArray(_unref2, 4),\n            cacheStart = _unref3[0],\n            cacheEnd = _unref3[1],\n            visibleStart = _unref3[2],\n            visibleEnd = _unref3[3];\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n        var _unref4 = unref(states),\n          scrollDir = _unref4.scrollDir,\n          scrollOffset = _unref4.scrollOffset,\n          updateRequested = _unref4.updateRequested;\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n      var scrollVertically = function scrollVertically(e) {\n        var _e$currentTarget = e.currentTarget,\n          clientHeight = _e$currentTarget.clientHeight,\n          scrollHeight = _e$currentTarget.scrollHeight,\n          scrollTop = _e$currentTarget.scrollTop;\n        var _states = unref(states);\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n        var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset: scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      var scrollHorizontally = function scrollHorizontally(e) {\n        var _e$currentTarget2 = e.currentTarget,\n          clientWidth = _e$currentTarget2.clientWidth,\n          scrollLeft = _e$currentTarget2.scrollLeft,\n          scrollWidth = _e$currentTarget2.scrollWidth;\n        var _states = unref(states);\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n        var direction = props.direction;\n        var scrollOffset = scrollLeft;\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n            case RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset: scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      var onScroll = function onScroll(e) {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n      var onScrollbarScroll = function onScrollbarScroll(distanceToGo, totalSteps) {\n        var offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n      var scrollTo = function scrollTo(offset) {\n        offset = Math.max(offset, 0);\n        if (offset === unref(states).scrollOffset) {\n          return;\n        }\n        states.value = _objectSpread(_objectSpread({}, unref(states)), {}, {\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      var scrollToItem = function scrollToItem(idx) {\n        var alignment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AUTO_ALIGNMENT;\n        var _unref5 = unref(states),\n          scrollOffset = _unref5.scrollOffset;\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));\n      };\n      var getItemStyle = function getItemStyle(idx) {\n        var direction = props.direction,\n          itemSize = props.itemSize,\n          layout = props.layout;\n        var itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        var style;\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          var offset = getItemOffset(props, idx, unref(dynamicSizeCache));\n          var size = getItemSize(props, idx, unref(dynamicSizeCache));\n          var horizontal = unref(_isHorizontal);\n          var isRtl = direction === RTL;\n          var offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : \"\".concat(offsetHorizontal, \"px\"),\n            right: isRtl ? \"\".concat(offsetHorizontal, \"px\") : void 0,\n            top: !horizontal ? \"\".concat(offset, \"px\") : 0,\n            height: !horizontal ? \"\".concat(size, \"px\") : \"100%\",\n            width: horizontal ? \"\".concat(size, \"px\") : \"100%\"\n          };\n        }\n        return style;\n      };\n      var resetIsScrolling = function resetIsScrolling() {\n        states.value.isScrolling = false;\n        nextTick(function () {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      var resetScrollTop = function resetScrollTop() {\n        var window = windowRef.value;\n        if (window) {\n          window.scrollTop = 0;\n        }\n      };\n      onMounted(function () {\n        if (!isClient) return;\n        var initScrollOffset = props.initScrollOffset;\n        var windowElement = unref(windowRef);\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(function () {\n        var direction = props.direction,\n          layout = props.layout;\n        var _unref6 = unref(states),\n          scrollOffset = _unref6.scrollOffset,\n          updateRequested = _unref6.updateRequested;\n        var windowElement = unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case RTL_OFFSET_NAG:\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n                case RTL_OFFSET_POS_ASC:\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n                default:\n                  {\n                    var clientWidth = windowElement.clientWidth,\n                      scrollWidth = windowElement.scrollWidth;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      onActivated(function () {\n        unref(windowRef).scrollTop = unref(states).scrollOffset;\n      });\n      var api = {\n        ns: ns,\n        clientSize: clientSize,\n        estimatedTotalSize: estimatedTotalSize,\n        windowStyle: windowStyle,\n        windowRef: windowRef,\n        innerRef: innerRef,\n        innerStyle: innerStyle,\n        itemsToRender: itemsToRender,\n        scrollbarRef: scrollbarRef,\n        states: states,\n        getItemStyle: getItemStyle,\n        onScroll: onScroll,\n        onScrollbarScroll: onScrollbarScroll,\n        onWheel: onWheel,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        resetScrollTop: resetScrollTop\n      };\n      expose({\n        windowRef: windowRef,\n        innerRef: innerRef,\n        getItemStyleCache: getItemStyleCache,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        resetScrollTop: resetScrollTop,\n        states: states\n      });\n      return api;\n    },\n    render: function render(ctx) {\n      var _a;\n      var $slots = ctx.$slots,\n        className = ctx.className,\n        clientSize = ctx.clientSize,\n        containerElement = ctx.containerElement,\n        data = ctx.data,\n        getItemStyle = ctx.getItemStyle,\n        innerElement = ctx.innerElement,\n        itemsToRender = ctx.itemsToRender,\n        innerStyle = ctx.innerStyle,\n        layout = ctx.layout,\n        total = ctx.total,\n        onScroll = ctx.onScroll,\n        onScrollbarScroll = ctx.onScrollbarScroll,\n        states = ctx.states,\n        useIsScrolling = ctx.useIsScrolling,\n        windowStyle = ctx.windowStyle,\n        ns = ctx.ns;\n      var _itemsToRender = _slicedToArray(itemsToRender, 2),\n        start = _itemsToRender[0],\n        end = _itemsToRender[1];\n      var Container = resolveDynamicComponent(containerElement);\n      var Inner = resolveDynamicComponent(innerElement);\n      var children = [];\n      if (total > 0) {\n        for (var i = start; i <= end; i++) {\n          children.push(h(Fragment, {\n            key: i\n          }, (_a = $slots[\"default\"]) == null ? void 0 : _a.call($slots, {\n            data: data,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          })));\n        }\n      }\n      var InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        \"default\": function _default() {\n          return children;\n        }\n      } : children)];\n      var scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize: clientSize,\n        layout: layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total: total\n      });\n      var listContainer = h(Container, {\n        \"class\": [ns.e(\"window\"), className],\n        style: windowStyle,\n        onScroll: onScroll,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? {\n        \"default\": function _default() {\n          return [InnerNode];\n        }\n      } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        \"class\": [ns.e(\"wrapper\"), states.scrollbarAlwaysOn ? \"always-on\" : \"\"]\n      }, [listContainer, scrollbar]);\n    }\n  });\n};\nexport { createList as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}