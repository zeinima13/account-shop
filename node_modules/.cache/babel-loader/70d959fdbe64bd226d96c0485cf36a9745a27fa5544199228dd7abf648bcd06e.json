{"ast":null,"code":"import _objectSpread from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { getCurrentInstance, shallowRef, ref, computed, unref } from 'vue';\nimport { debounce } from 'lodash-unified';\nimport { FixedDir } from '../constants.mjs';\nimport { isNumber } from '../../../../utils/types.mjs';\nvar useRow = function useRow(props, _ref) {\n  var mainTableRef = _ref.mainTableRef,\n    leftTableRef = _ref.leftTableRef,\n    rightTableRef = _ref.rightTableRef,\n    tableInstance = _ref.tableInstance,\n    ns = _ref.ns,\n    isScrolling = _ref.isScrolling;\n  var vm = getCurrentInstance();\n  var emit = vm.emit;\n  var isResetting = shallowRef(false);\n  var expandedRowKeys = ref(props.defaultExpandedRowKeys || []);\n  var lastRenderedRowIndex = ref(-1);\n  var resetIndex = shallowRef(null);\n  var rowHeights = ref({});\n  var pendingRowHeights = ref({});\n  var leftTableHeights = shallowRef({});\n  var mainTableHeights = shallowRef({});\n  var rightTableHeights = shallowRef({});\n  var isDynamic = computed(function () {\n    return isNumber(props.estimatedRowHeight);\n  });\n  function onRowsRendered(params) {\n    var _a;\n    (_a = props.onRowsRendered) == null ? void 0 : _a.call(props, params);\n    if (params.rowCacheEnd > unref(lastRenderedRowIndex)) {\n      lastRenderedRowIndex.value = params.rowCacheEnd;\n    }\n  }\n  function onRowHovered(_ref2) {\n    var hovered = _ref2.hovered,\n      rowKey = _ref2.rowKey;\n    if (isScrolling.value) {\n      return;\n    }\n    var tableRoot = tableInstance.vnode.el;\n    var rows = tableRoot.querySelectorAll(\"[rowkey=\\\"\".concat(String(rowKey), \"\\\"]\"));\n    rows.forEach(function (row) {\n      if (hovered) {\n        row.classList.add(ns.is(\"hovered\"));\n      } else {\n        row.classList.remove(ns.is(\"hovered\"));\n      }\n    });\n  }\n  function onRowExpanded(_ref3) {\n    var expanded = _ref3.expanded,\n      rowData = _ref3.rowData,\n      rowIndex = _ref3.rowIndex,\n      rowKey = _ref3.rowKey;\n    var _a, _b;\n    var _expandedRowKeys = _toConsumableArray(unref(expandedRowKeys));\n    var currentKeyIndex = _expandedRowKeys.indexOf(rowKey);\n    if (expanded) {\n      if (currentKeyIndex === -1) _expandedRowKeys.push(rowKey);\n    } else {\n      if (currentKeyIndex > -1) _expandedRowKeys.splice(currentKeyIndex, 1);\n    }\n    expandedRowKeys.value = _expandedRowKeys;\n    emit(\"update:expandedRowKeys\", _expandedRowKeys);\n    (_a = props.onRowExpand) == null ? void 0 : _a.call(props, {\n      expanded: expanded,\n      rowData: rowData,\n      rowIndex: rowIndex,\n      rowKey: rowKey\n    });\n    (_b = props.onExpandedRowsChange) == null ? void 0 : _b.call(props, _expandedRowKeys);\n  }\n  var flushingRowHeights = debounce(function () {\n    var _a, _b, _c, _d;\n    isResetting.value = true;\n    rowHeights.value = _objectSpread(_objectSpread({}, unref(rowHeights)), unref(pendingRowHeights));\n    resetAfterIndex(unref(resetIndex), false);\n    pendingRowHeights.value = {};\n    resetIndex.value = null;\n    (_a = mainTableRef.value) == null ? void 0 : _a.forceUpdate();\n    (_b = leftTableRef.value) == null ? void 0 : _b.forceUpdate();\n    (_c = rightTableRef.value) == null ? void 0 : _c.forceUpdate();\n    (_d = vm.proxy) == null ? void 0 : _d.$forceUpdate();\n    isResetting.value = false;\n  }, 0);\n  function resetAfterIndex(index) {\n    var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!unref(isDynamic)) return;\n    [mainTableRef, leftTableRef, rightTableRef].forEach(function (tableRef) {\n      var table = unref(tableRef);\n      if (table) table.resetAfterRowIndex(index, forceUpdate);\n    });\n  }\n  function resetHeights(rowKey, height, rowIdx) {\n    var resetIdx = unref(resetIndex);\n    if (resetIdx === null) {\n      resetIndex.value = rowIdx;\n    } else {\n      if (resetIdx > rowIdx) {\n        resetIndex.value = rowIdx;\n      }\n    }\n    pendingRowHeights.value[rowKey] = height;\n  }\n  function onRowHeightChange(_ref4, fixedDir) {\n    var rowKey = _ref4.rowKey,\n      height = _ref4.height,\n      rowIndex = _ref4.rowIndex;\n    if (!fixedDir) {\n      mainTableHeights.value[rowKey] = height;\n    } else {\n      if (fixedDir === FixedDir.RIGHT) {\n        rightTableHeights.value[rowKey] = height;\n      } else {\n        leftTableHeights.value[rowKey] = height;\n      }\n    }\n    var maximumHeight = Math.max.apply(Math, _toConsumableArray([leftTableHeights, rightTableHeights, mainTableHeights].map(function (records) {\n      return records.value[rowKey] || 0;\n    })));\n    if (unref(rowHeights)[rowKey] !== maximumHeight) {\n      resetHeights(rowKey, maximumHeight, rowIndex);\n      flushingRowHeights();\n    }\n  }\n  return {\n    expandedRowKeys: expandedRowKeys,\n    lastRenderedRowIndex: lastRenderedRowIndex,\n    isDynamic: isDynamic,\n    isResetting: isResetting,\n    rowHeights: rowHeights,\n    resetAfterIndex: resetAfterIndex,\n    onRowExpanded: onRowExpanded,\n    onRowHovered: onRowHovered,\n    onRowsRendered: onRowsRendered,\n    onRowHeightChange: onRowHeightChange\n  };\n};\nexport { useRow };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}