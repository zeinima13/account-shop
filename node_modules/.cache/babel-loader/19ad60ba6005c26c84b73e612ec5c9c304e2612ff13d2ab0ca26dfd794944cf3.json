{"ast":null,"code":"import _objectSpread from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport { computed, unref, shallowRef, ref, watch, onBeforeUnmount } from 'vue';\nimport { createPopper } from '@popperjs/core';\nimport { fromPairs } from 'lodash-unified';\nvar usePopper = function usePopper(referenceElementRef, popperElementRef) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var stateUpdater = {\n    name: \"updateState\",\n    enabled: true,\n    phase: \"write\",\n    fn: function fn(_ref) {\n      var state = _ref.state;\n      var derivedState = deriveState(state);\n      Object.assign(states.value, derivedState);\n    },\n    requires: [\"computeStyles\"]\n  };\n  var options = computed(function () {\n    var _unref = unref(opts),\n      onFirstUpdate = _unref.onFirstUpdate,\n      placement = _unref.placement,\n      strategy = _unref.strategy,\n      modifiers = _unref.modifiers;\n    return {\n      onFirstUpdate: onFirstUpdate,\n      placement: placement || \"bottom\",\n      strategy: strategy || \"absolute\",\n      modifiers: [].concat(_toConsumableArray(modifiers || []), [stateUpdater, {\n        name: \"applyStyles\",\n        enabled: false\n      }])\n    };\n  });\n  var instanceRef = shallowRef();\n  var states = ref({\n    styles: {\n      popper: {\n        position: unref(options).strategy,\n        left: \"0\",\n        top: \"0\"\n      },\n      arrow: {\n        position: \"absolute\"\n      }\n    },\n    attributes: {}\n  });\n  var destroy = function destroy() {\n    if (!instanceRef.value) return;\n    instanceRef.value.destroy();\n    instanceRef.value = void 0;\n  };\n  watch(options, function (newOptions) {\n    var instance = unref(instanceRef);\n    if (instance) {\n      instance.setOptions(newOptions);\n    }\n  }, {\n    deep: true\n  });\n  watch([referenceElementRef, popperElementRef], function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      referenceElement = _ref3[0],\n      popperElement = _ref3[1];\n    destroy();\n    if (!referenceElement || !popperElement) return;\n    instanceRef.value = createPopper(referenceElement, popperElement, unref(options));\n  });\n  onBeforeUnmount(function () {\n    destroy();\n  });\n  return {\n    state: computed(function () {\n      var _a;\n      return _objectSpread({}, ((_a = unref(instanceRef)) == null ? void 0 : _a.state) || {});\n    }),\n    styles: computed(function () {\n      return unref(states).styles;\n    }),\n    attributes: computed(function () {\n      return unref(states).attributes;\n    }),\n    update: function update() {\n      var _a;\n      return (_a = unref(instanceRef)) == null ? void 0 : _a.update();\n    },\n    forceUpdate: function forceUpdate() {\n      var _a;\n      return (_a = unref(instanceRef)) == null ? void 0 : _a.forceUpdate();\n    },\n    instanceRef: computed(function () {\n      return unref(instanceRef);\n    })\n  };\n};\nfunction deriveState(state) {\n  var elements = Object.keys(state.elements);\n  var styles = fromPairs(elements.map(function (element) {\n    return [element, state.styles[element] || {}];\n  }));\n  var attributes = fromPairs(elements.map(function (element) {\n    return [element, state.attributes[element]];\n  }));\n  return {\n    styles: styles,\n    attributes: attributes\n  };\n}\nexport { usePopper };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}