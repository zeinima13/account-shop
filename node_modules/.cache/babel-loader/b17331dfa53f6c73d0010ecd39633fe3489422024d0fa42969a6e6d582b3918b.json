{"ast":null,"code":"import _slicedToArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { defineComponent, computed, shallowRef, ref, onMounted, watch, onBeforeUnmount, openBlock, createElementBlock, normalizeStyle, renderSlot } from 'vue';\nimport { useMutationObserver } from '@vueuse/core';\nimport { watermarkProps } from './watermark.mjs';\nimport { reRendering, getStyleStr, getPixelRatio } from './utils.mjs';\nimport useClips, { FontGap } from './useClips.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { isArray } from '@vue/shared';\nvar __default__ = defineComponent({\n  name: \"ElWatermark\"\n});\nvar _sfc_main = /* @__PURE__ */defineComponent(_objectSpread(_objectSpread({}, __default__), {}, {\n  props: watermarkProps,\n  setup: function setup(__props) {\n    var props = __props;\n    var style = {\n      position: \"relative\"\n    };\n    var color = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.color) != null ? _b : \"rgba(0,0,0,.15)\";\n    });\n    var fontSize = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontSize) != null ? _b : 16;\n    });\n    var fontWeight = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontWeight) != null ? _b : \"normal\";\n    });\n    var fontStyle = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontStyle) != null ? _b : \"normal\";\n    });\n    var fontFamily = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontFamily) != null ? _b : \"sans-serif\";\n    });\n    var textAlign = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.textAlign) != null ? _b : \"center\";\n    });\n    var textBaseline = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.textBaseline) != null ? _b : \"hanging\";\n    });\n    var gapX = computed(function () {\n      return props.gap[0];\n    });\n    var gapY = computed(function () {\n      return props.gap[1];\n    });\n    var gapXCenter = computed(function () {\n      return gapX.value / 2;\n    });\n    var gapYCenter = computed(function () {\n      return gapY.value / 2;\n    });\n    var offsetLeft = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.offset) == null ? void 0 : _a[0]) != null ? _b : gapXCenter.value;\n    });\n    var offsetTop = computed(function () {\n      var _a, _b;\n      return (_b = (_a = props.offset) == null ? void 0 : _a[1]) != null ? _b : gapYCenter.value;\n    });\n    var getMarkStyle = function getMarkStyle() {\n      var markStyle = {\n        zIndex: props.zIndex,\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        width: \"100%\",\n        height: \"100%\",\n        pointerEvents: \"none\",\n        backgroundRepeat: \"repeat\"\n      };\n      var positionLeft = offsetLeft.value - gapXCenter.value;\n      var positionTop = offsetTop.value - gapYCenter.value;\n      if (positionLeft > 0) {\n        markStyle.left = \"\".concat(positionLeft, \"px\");\n        markStyle.width = \"calc(100% - \".concat(positionLeft, \"px)\");\n        positionLeft = 0;\n      }\n      if (positionTop > 0) {\n        markStyle.top = \"\".concat(positionTop, \"px\");\n        markStyle.height = \"calc(100% - \".concat(positionTop, \"px)\");\n        positionTop = 0;\n      }\n      markStyle.backgroundPosition = \"\".concat(positionLeft, \"px \").concat(positionTop, \"px\");\n      return markStyle;\n    };\n    var containerRef = shallowRef(null);\n    var watermarkRef = shallowRef();\n    var stopObservation = ref(false);\n    var destroyWatermark = function destroyWatermark() {\n      if (watermarkRef.value) {\n        watermarkRef.value.remove();\n        watermarkRef.value = void 0;\n      }\n    };\n    var appendWatermark = function appendWatermark(base64Url, markWidth) {\n      var _a;\n      if (containerRef.value && watermarkRef.value) {\n        stopObservation.value = true;\n        watermarkRef.value.setAttribute(\"style\", getStyleStr(_objectSpread(_objectSpread({}, getMarkStyle()), {}, {\n          backgroundImage: \"url('\".concat(base64Url, \"')\"),\n          backgroundSize: \"\".concat(Math.floor(markWidth), \"px\")\n        })));\n        (_a = containerRef.value) == null ? void 0 : _a.append(watermarkRef.value);\n        setTimeout(function () {\n          stopObservation.value = false;\n        });\n      }\n    };\n    var getMarkSize = function getMarkSize(ctx) {\n      var defaultWidth = 120;\n      var defaultHeight = 64;\n      var image = props.image;\n      var content = props.content;\n      var width = props.width;\n      var height = props.height;\n      if (!image && ctx.measureText) {\n        ctx.font = \"\".concat(Number(fontSize.value), \"px \").concat(fontFamily.value);\n        var contents = isArray(content) ? content : [content];\n        var sizes = contents.map(function (item) {\n          var metrics = ctx.measureText(item);\n          return [metrics.width, metrics.fontBoundingBoxAscent !== void 0 ? metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent : metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent];\n        });\n        defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(function (size) {\n          return size[0];\n        }))));\n        defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(function (size) {\n          return size[1];\n        })))) * contents.length + (contents.length - 1) * FontGap;\n      }\n      return [width != null ? width : defaultWidth, height != null ? height : defaultHeight];\n    };\n    var getClips = useClips();\n    var renderWatermark = function renderWatermark() {\n      var canvas = document.createElement(\"canvas\");\n      var ctx = canvas.getContext(\"2d\");\n      var image = props.image;\n      var content = props.content;\n      var rotate = props.rotate;\n      if (ctx) {\n        if (!watermarkRef.value) {\n          watermarkRef.value = document.createElement(\"div\");\n        }\n        var ratio = getPixelRatio();\n        var _getMarkSize = getMarkSize(ctx),\n          _getMarkSize2 = _slicedToArray(_getMarkSize, 2),\n          markWidth = _getMarkSize2[0],\n          markHeight = _getMarkSize2[1];\n        var drawCanvas = function drawCanvas(drawContent) {\n          var _getClips = getClips(drawContent || \"\", rotate, ratio, markWidth, markHeight, {\n              color: color.value,\n              fontSize: fontSize.value,\n              fontStyle: fontStyle.value,\n              fontWeight: fontWeight.value,\n              fontFamily: fontFamily.value,\n              textAlign: textAlign.value,\n              textBaseline: textBaseline.value\n            }, gapX.value, gapY.value),\n            _getClips2 = _slicedToArray(_getClips, 2),\n            textClips = _getClips2[0],\n            clipWidth = _getClips2[1];\n          appendWatermark(textClips, clipWidth);\n        };\n        if (image) {\n          var img = new Image();\n          img.onload = function () {\n            drawCanvas(img);\n          };\n          img.onerror = function () {\n            drawCanvas(content);\n          };\n          img.crossOrigin = \"anonymous\";\n          img.referrerPolicy = \"no-referrer\";\n          img.src = image;\n        } else {\n          drawCanvas(content);\n        }\n      }\n    };\n    onMounted(function () {\n      renderWatermark();\n    });\n    watch(function () {\n      return props;\n    }, function () {\n      renderWatermark();\n    }, {\n      deep: true,\n      flush: \"post\"\n    });\n    onBeforeUnmount(function () {\n      destroyWatermark();\n    });\n    var onMutate = function onMutate(mutations) {\n      if (stopObservation.value) {\n        return;\n      }\n      mutations.forEach(function (mutation) {\n        if (reRendering(mutation, watermarkRef.value)) {\n          destroyWatermark();\n          renderWatermark();\n        }\n      });\n    };\n    useMutationObserver(containerRef, onMutate, {\n      attributes: true,\n      subtree: true,\n      childList: true\n    });\n    return function (_ctx, _cache) {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"containerRef\",\n        ref: containerRef,\n        style: normalizeStyle([style])\n      }, [renderSlot(_ctx.$slots, \"default\")], 4);\n    };\n  }\n}));\nvar Watermark = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"watermark.vue\"]]);\nexport { Watermark as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}