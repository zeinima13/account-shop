{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { ref, shallowRef, watch, computed, nextTick } from 'vue';\nimport { TreeOptionsEnum, NODE_CLICK, NODE_DROP, CURRENT_CHANGE, NODE_EXPAND, NODE_COLLAPSE } from '../virtual-tree.mjs';\nimport { useCheck } from './useCheck.mjs';\nimport { useFilter } from './useFilter.mjs';\nimport { isObject } from '@vue/shared';\nfunction useTree(props, emit) {\n  var expandedKeySet = ref(new Set(props.defaultExpandedKeys));\n  var currentKey = ref();\n  var tree = shallowRef();\n  var listRef = ref();\n  watch(function () {\n    return props.currentNodeKey;\n  }, function (key) {\n    currentKey.value = key;\n  }, {\n    immediate: true\n  });\n  watch(function () {\n    return props.data;\n  }, function (data) {\n    setData(data);\n  }, {\n    immediate: true\n  });\n  var _useCheck = useCheck(props, tree),\n    isIndeterminate = _useCheck.isIndeterminate,\n    isChecked = _useCheck.isChecked,\n    toggleCheckbox = _useCheck.toggleCheckbox,\n    getCheckedKeys = _useCheck.getCheckedKeys,\n    getCheckedNodes = _useCheck.getCheckedNodes,\n    getHalfCheckedKeys = _useCheck.getHalfCheckedKeys,\n    getHalfCheckedNodes = _useCheck.getHalfCheckedNodes,\n    setChecked = _useCheck.setChecked,\n    setCheckedKeys = _useCheck.setCheckedKeys;\n  var _useFilter = useFilter(props, tree),\n    doFilter = _useFilter.doFilter,\n    hiddenNodeKeySet = _useFilter.hiddenNodeKeySet,\n    isForceHiddenExpandIcon = _useFilter.isForceHiddenExpandIcon;\n  var valueKey = computed(function () {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.value) || TreeOptionsEnum.KEY;\n  });\n  var childrenKey = computed(function () {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.children) || TreeOptionsEnum.CHILDREN;\n  });\n  var disabledKey = computed(function () {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.disabled) || TreeOptionsEnum.DISABLED;\n  });\n  var labelKey = computed(function () {\n    var _a;\n    return ((_a = props.props) == null ? void 0 : _a.label) || TreeOptionsEnum.LABEL;\n  });\n  var flattenTree = computed(function () {\n    var _a;\n    var expandedKeys = expandedKeySet.value;\n    var hiddenKeys = hiddenNodeKeySet.value;\n    var flattenNodes = [];\n    var nodes = ((_a = tree.value) == null ? void 0 : _a.treeNodes) || [];\n    var stack = [];\n    for (var i = nodes.length - 1; i >= 0; --i) {\n      stack.push(nodes[i]);\n    }\n    while (stack.length) {\n      var node = stack.pop();\n      if (hiddenKeys.has(node.key)) continue;\n      flattenNodes.push(node);\n      if (node.children && expandedKeys.has(node.key)) {\n        for (var _i = node.children.length - 1; _i >= 0; --_i) {\n          stack.push(node.children[_i]);\n        }\n      }\n    }\n    return flattenNodes;\n  });\n  var isNotEmpty = computed(function () {\n    return flattenTree.value.length > 0;\n  });\n  function createTree(data) {\n    var treeNodeMap = /* @__PURE__ */new Map();\n    var levelTreeNodeMap = /* @__PURE__ */new Map();\n    var maxLevel = 1;\n    function traverse(nodes) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;\n      var _a;\n      var siblings = [];\n      var _iterator = _createForOfIteratorHelper(nodes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rawNode = _step.value;\n          var value = getKey(rawNode);\n          var node = {\n            level: level,\n            key: value,\n            data: rawNode\n          };\n          node.label = getLabel(rawNode);\n          node.parent = parent;\n          var children = getChildren(rawNode);\n          node.disabled = getDisabled(rawNode);\n          node.isLeaf = !children || children.length === 0;\n          if (children && children.length) {\n            node.children = traverse(children, level + 1, node);\n          }\n          siblings.push(node);\n          treeNodeMap.set(value, node);\n          if (!levelTreeNodeMap.has(level)) {\n            levelTreeNodeMap.set(level, []);\n          }\n          (_a = levelTreeNodeMap.get(level)) == null ? void 0 : _a.push(node);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (level > maxLevel) {\n        maxLevel = level;\n      }\n      return siblings;\n    }\n    var treeNodes = traverse(data);\n    return {\n      treeNodeMap: treeNodeMap,\n      levelTreeNodeMap: levelTreeNodeMap,\n      maxLevel: maxLevel,\n      treeNodes: treeNodes\n    };\n  }\n  function filter(query) {\n    var keys = doFilter(query);\n    if (keys) {\n      expandedKeySet.value = keys;\n    }\n  }\n  function getChildren(node) {\n    return node[childrenKey.value];\n  }\n  function getKey(node) {\n    if (!node) {\n      return \"\";\n    }\n    return node[valueKey.value];\n  }\n  function getDisabled(node) {\n    return node[disabledKey.value];\n  }\n  function getLabel(node) {\n    return node[labelKey.value];\n  }\n  function toggleExpand(node) {\n    var expandedKeys = expandedKeySet.value;\n    if (expandedKeys.has(node.key)) {\n      collapseNode(node);\n    } else {\n      expandNode(node);\n    }\n  }\n  function setExpandedKeys(keys) {\n    var expandedKeys = /* @__PURE__ */new Set();\n    var nodeMap = tree.value.treeNodeMap;\n    keys.forEach(function (k) {\n      var node = nodeMap.get(k);\n      while (node && !expandedKeys.has(node.key)) {\n        expandedKeys.add(node.key);\n        node = node.parent;\n      }\n    });\n    expandedKeySet.value = expandedKeys;\n  }\n  function handleNodeClick(node, e) {\n    emit(NODE_CLICK, node.data, node, e);\n    handleCurrentChange(node);\n    if (props.expandOnClickNode) {\n      toggleExpand(node);\n    }\n    if (props.showCheckbox && props.checkOnClickNode && !node.disabled) {\n      toggleCheckbox(node, !isChecked(node), true);\n    }\n  }\n  function handleNodeDrop(node, e) {\n    emit(NODE_DROP, node.data, node, e);\n  }\n  function handleCurrentChange(node) {\n    if (!isCurrent(node)) {\n      currentKey.value = node.key;\n      emit(CURRENT_CHANGE, node.data, node);\n    }\n  }\n  function handleNodeCheck(node, checked) {\n    toggleCheckbox(node, checked);\n  }\n  function expandNode(node) {\n    var keySet = expandedKeySet.value;\n    if (tree.value && props.accordion) {\n      var treeNodeMap = tree.value.treeNodeMap;\n      keySet.forEach(function (key) {\n        var treeNode = treeNodeMap.get(key);\n        if (node && node.level === (treeNode == null ? void 0 : treeNode.level)) {\n          keySet[\"delete\"](key);\n        }\n      });\n    }\n    keySet.add(node.key);\n    emit(NODE_EXPAND, node.data, node);\n  }\n  function collapseNode(node) {\n    expandedKeySet.value[\"delete\"](node.key);\n    emit(NODE_COLLAPSE, node.data, node);\n  }\n  function isExpanded(node) {\n    return expandedKeySet.value.has(node.key);\n  }\n  function isDisabled(node) {\n    return !!node.disabled;\n  }\n  function isCurrent(node) {\n    var current = currentKey.value;\n    return current !== void 0 && current === node.key;\n  }\n  function getCurrentNode() {\n    var _a, _b;\n    if (!currentKey.value) return void 0;\n    return (_b = (_a = tree.value) == null ? void 0 : _a.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;\n  }\n  function getCurrentKey() {\n    return currentKey.value;\n  }\n  function setCurrentKey(key) {\n    currentKey.value = key;\n  }\n  function setData(data) {\n    nextTick(function () {\n      return tree.value = createTree(data);\n    });\n  }\n  function getNode(data) {\n    var _a;\n    var key = isObject(data) ? getKey(data) : data;\n    return (_a = tree.value) == null ? void 0 : _a.treeNodeMap.get(key);\n  }\n  function scrollToNode(key) {\n    var strategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n    var node = getNode(key);\n    if (node && listRef.value) {\n      listRef.value.scrollToItem(flattenTree.value.indexOf(node), strategy);\n    }\n  }\n  function scrollTo(offset) {\n    var _a;\n    (_a = listRef.value) == null ? void 0 : _a.scrollTo(offset);\n  }\n  return {\n    tree: tree,\n    flattenTree: flattenTree,\n    isNotEmpty: isNotEmpty,\n    listRef: listRef,\n    getKey: getKey,\n    getChildren: getChildren,\n    toggleExpand: toggleExpand,\n    toggleCheckbox: toggleCheckbox,\n    isExpanded: isExpanded,\n    isChecked: isChecked,\n    isIndeterminate: isIndeterminate,\n    isDisabled: isDisabled,\n    isCurrent: isCurrent,\n    isForceHiddenExpandIcon: isForceHiddenExpandIcon,\n    handleNodeClick: handleNodeClick,\n    handleNodeDrop: handleNodeDrop,\n    handleNodeCheck: handleNodeCheck,\n    getCurrentNode: getCurrentNode,\n    getCurrentKey: getCurrentKey,\n    setCurrentKey: setCurrentKey,\n    getCheckedKeys: getCheckedKeys,\n    getCheckedNodes: getCheckedNodes,\n    getHalfCheckedKeys: getHalfCheckedKeys,\n    getHalfCheckedNodes: getHalfCheckedNodes,\n    setChecked: setChecked,\n    setCheckedKeys: setCheckedKeys,\n    filter: filter,\n    setData: setData,\n    getNode: getNode,\n    expandNode: expandNode,\n    collapseNode: collapseNode,\n    setExpandedKeys: setExpandedKeys,\n    scrollToNode: scrollToNode,\n    scrollTo: scrollTo\n  };\n}\nexport { useTree };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}