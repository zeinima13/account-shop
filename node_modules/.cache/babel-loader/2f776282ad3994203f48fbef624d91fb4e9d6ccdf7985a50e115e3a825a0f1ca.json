{"ast":null,"code":"import _toConsumableArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { defineComponent, inject, ref, computed, watch, onMounted, onUpdated, createVNode, nextTick } from 'vue';\nimport { useDocumentVisibility, useWindowFocus, useResizeObserver } from '@vueuse/core';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue';\nimport TabBar from './tab-bar2.mjs';\nimport { tabsRootContextKey } from './constants.mjs';\nimport { buildProps, definePropType } from '../../../utils/vue/props/runtime.mjs';\nimport { mutable } from '../../../utils/typescript.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { capitalize } from '../../../utils/strings.mjs';\nvar tabNavProps = buildProps({\n  panes: {\n    type: definePropType(Array),\n    \"default\": function _default() {\n      return mutable([]);\n    }\n  },\n  currentName: {\n    type: [String, Number],\n    \"default\": \"\"\n  },\n  editable: Boolean,\n  type: {\n    type: String,\n    values: [\"card\", \"border-card\", \"\"],\n    \"default\": \"\"\n  },\n  stretch: Boolean\n});\nvar tabNavEmits = {\n  tabClick: function tabClick(tab, tabName, ev) {\n    return ev instanceof Event;\n  },\n  tabRemove: function tabRemove(tab, ev) {\n    return ev instanceof Event;\n  }\n};\nvar COMPONENT_NAME = \"ElTabNav\";\nvar TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  emits: tabNavEmits,\n  setup: function setup(props, _ref) {\n    var expose = _ref.expose,\n      emit = _ref.emit;\n    var rootTabs = inject(tabsRootContextKey);\n    if (!rootTabs) throwError(COMPONENT_NAME, \"<el-tabs><tab-nav /></el-tabs>\");\n    var ns = useNamespace(\"tabs\");\n    var visibility = useDocumentVisibility();\n    var focused = useWindowFocus();\n    var navScroll$ = ref();\n    var nav$ = ref();\n    var el$ = ref();\n    var tabBarRef = ref();\n    var scrollable = ref(false);\n    var navOffset = ref(0);\n    var isFocus = ref(false);\n    var focusable = ref(true);\n    var sizeName = computed(function () {\n      return [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition) ? \"width\" : \"height\";\n    });\n    var navStyle = computed(function () {\n      var dir = sizeName.value === \"width\" ? \"X\" : \"Y\";\n      return {\n        transform: \"translate\".concat(dir, \"(-\").concat(navOffset.value, \"px)\")\n      };\n    });\n    var scrollPrev = function scrollPrev() {\n      if (!navScroll$.value) return;\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n      if (!currentOffset) return;\n      var newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n      navOffset.value = newOffset;\n    };\n    var scrollNext = function scrollNext() {\n      if (!navScroll$.value || !nav$.value) return;\n      var navSize = nav$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n      if (navSize - currentOffset <= containerSize) return;\n      var newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;\n      navOffset.value = newOffset;\n    };\n    var scrollToActiveTab = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var nav, activeTab, navScroll, isHorizontal, activeTabBounding, navScrollBounding, maxOffset, currentOffset, newOffset;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              nav = nav$.value;\n              if (!(!scrollable.value || !el$.value || !navScroll$.value || !nav)) {\n                _context.next = 3;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 3:\n              _context.next = 5;\n              return nextTick();\n            case 5:\n              activeTab = el$.value.querySelector(\".is-active\");\n              if (activeTab) {\n                _context.next = 8;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 8:\n              navScroll = navScroll$.value;\n              isHorizontal = [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition);\n              activeTabBounding = activeTab.getBoundingClientRect();\n              navScrollBounding = navScroll.getBoundingClientRect();\n              maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n              currentOffset = navOffset.value;\n              newOffset = currentOffset;\n              if (isHorizontal) {\n                if (activeTabBounding.left < navScrollBounding.left) {\n                  newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n                }\n                if (activeTabBounding.right > navScrollBounding.right) {\n                  newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n                }\n              } else {\n                if (activeTabBounding.top < navScrollBounding.top) {\n                  newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n                }\n                if (activeTabBounding.bottom > navScrollBounding.bottom) {\n                  newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n                }\n              }\n              newOffset = Math.max(newOffset, 0);\n              navOffset.value = Math.min(newOffset, maxOffset);\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function scrollToActiveTab() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    var update = function update() {\n      var _a;\n      if (!nav$.value || !navScroll$.value) return;\n      props.stretch && ((_a = tabBarRef.value) == null ? void 0 : _a.update());\n      var navSize = nav$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n      if (containerSize < navSize) {\n        scrollable.value = scrollable.value || {};\n        scrollable.value.prev = currentOffset;\n        scrollable.value.next = currentOffset + containerSize < navSize;\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize;\n        }\n      } else {\n        scrollable.value = false;\n        if (currentOffset > 0) {\n          navOffset.value = 0;\n        }\n      }\n    };\n    var changeTab = function changeTab(event) {\n      var step = 0;\n      switch (event.code) {\n        case EVENT_CODE.left:\n        case EVENT_CODE.up:\n          step = -1;\n          break;\n        case EVENT_CODE.right:\n        case EVENT_CODE.down:\n          step = 1;\n          break;\n        default:\n          return;\n      }\n      var tabList = Array.from(event.currentTarget.querySelectorAll(\"[role=tab]:not(.is-disabled)\"));\n      var currentIndex = tabList.indexOf(event.target);\n      var nextIndex = currentIndex + step;\n      if (nextIndex < 0) {\n        nextIndex = tabList.length - 1;\n      } else if (nextIndex >= tabList.length) {\n        nextIndex = 0;\n      }\n      tabList[nextIndex].focus({\n        preventScroll: true\n      });\n      tabList[nextIndex].click();\n      setFocus();\n    };\n    var setFocus = function setFocus() {\n      if (focusable.value) isFocus.value = true;\n    };\n    var removeFocus = function removeFocus() {\n      return isFocus.value = false;\n    };\n    watch(visibility, function (visibility2) {\n      if (visibility2 === \"hidden\") {\n        focusable.value = false;\n      } else if (visibility2 === \"visible\") {\n        setTimeout(function () {\n          return focusable.value = true;\n        }, 50);\n      }\n    });\n    watch(focused, function (focused2) {\n      if (focused2) {\n        setTimeout(function () {\n          return focusable.value = true;\n        }, 50);\n      } else {\n        focusable.value = false;\n      }\n    });\n    useResizeObserver(el$, update);\n    onMounted(function () {\n      return setTimeout(function () {\n        return scrollToActiveTab();\n      }, 0);\n    });\n    onUpdated(function () {\n      return update();\n    });\n    expose({\n      scrollToActiveTab: scrollToActiveTab,\n      removeFocus: removeFocus\n    });\n    return function () {\n      var scrollBtn = scrollable.value ? [createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-prev\"), ns.is(\"disabled\", !scrollable.value.prev)],\n        \"onClick\": scrollPrev\n      }, [createVNode(ElIcon, null, {\n        \"default\": function _default() {\n          return [createVNode(ArrowLeft, null, null)];\n        }\n      })]), createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-next\"), ns.is(\"disabled\", !scrollable.value.next)],\n        \"onClick\": scrollNext\n      }, [createVNode(ElIcon, null, {\n        \"default\": function _default() {\n          return [createVNode(ArrowRight, null, null)];\n        }\n      })])] : null;\n      var tabs = props.panes.map(function (pane, index) {\n        var _a, _b, _c, _d;\n        var uid = pane.uid;\n        var disabled = pane.props.disabled;\n        var tabName = (_b = (_a = pane.props.name) != null ? _a : pane.index) != null ? _b : \"\".concat(index);\n        var closable = !disabled && (pane.isClosable || props.editable);\n        pane.index = \"\".concat(index);\n        var btnClose = closable ? createVNode(ElIcon, {\n          \"class\": \"is-icon-close\",\n          \"onClick\": function onClick(ev) {\n            return emit(\"tabRemove\", pane, ev);\n          }\n        }, {\n          \"default\": function _default() {\n            return [createVNode(Close, null, null)];\n          }\n        }) : null;\n        var tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;\n        var tabindex = !disabled && pane.active ? 0 : -1;\n        return createVNode(\"div\", {\n          \"ref\": \"tab-\".concat(uid),\n          \"class\": [ns.e(\"item\"), ns.is(rootTabs.props.tabPosition), ns.is(\"active\", pane.active), ns.is(\"disabled\", disabled), ns.is(\"closable\", closable), ns.is(\"focus\", isFocus.value)],\n          \"id\": \"tab-\".concat(tabName),\n          \"key\": \"tab-\".concat(uid),\n          \"aria-controls\": \"pane-\".concat(tabName),\n          \"role\": \"tab\",\n          \"aria-selected\": pane.active,\n          \"tabindex\": tabindex,\n          \"onFocus\": function onFocus() {\n            return setFocus();\n          },\n          \"onBlur\": function onBlur() {\n            return removeFocus();\n          },\n          \"onClick\": function onClick(ev) {\n            removeFocus();\n            emit(\"tabClick\", pane, tabName, ev);\n          },\n          \"onKeydown\": function onKeydown(ev) {\n            if (closable && (ev.code === EVENT_CODE[\"delete\"] || ev.code === EVENT_CODE.backspace)) {\n              emit(\"tabRemove\", pane, ev);\n            }\n          }\n        }, [tabLabelContent, btnClose].concat());\n      });\n      return createVNode(\"div\", {\n        \"ref\": el$,\n        \"class\": [ns.e(\"nav-wrap\"), ns.is(\"scrollable\", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]\n      }, [scrollBtn, createVNode(\"div\", {\n        \"class\": ns.e(\"nav-scroll\"),\n        \"ref\": navScroll$\n      }, [createVNode(\"div\", {\n        \"class\": [ns.e(\"nav\"), ns.is(rootTabs.props.tabPosition), ns.is(\"stretch\", props.stretch && [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition))],\n        \"ref\": nav$,\n        \"style\": navStyle.value,\n        \"role\": \"tablist\",\n        \"onKeydown\": changeTab\n      }, [!props.type ? createVNode(TabBar, {\n        \"ref\": tabBarRef,\n        \"tabs\": _toConsumableArray(props.panes)\n      }, null) : null, tabs].concat())])]);\n    };\n  }\n});\nexport { TabNav as default, tabNavEmits, tabNavProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}