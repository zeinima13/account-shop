{"ast":null,"code":"import _typeof from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport createGrid from '../builders/build-grid.mjs';\nimport { DEFAULT_DYNAMIC_LIST_ITEM_SIZE, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, SMART_ALIGNMENT } from '../defaults.mjs';\nimport { isFunction } from '@vue/shared';\nimport { throwError } from '../../../../utils/error.mjs';\nimport { isNumber, isUndefined } from '../../../../utils/types.mjs';\nvar max = Math.max,\n  min = Math.min,\n  floor = Math.floor;\nvar SCOPE = \"ElDynamicSizeGrid\";\nvar ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nvar ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\nvar getItemFromCache = function getItemFromCache(props, index, gridCache, type) {\n  var _ref = [gridCache[type], props[ACCESS_SIZER_KEY_MAP[type]], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]],\n    cachedItems = _ref[0],\n    sizer = _ref[1],\n    lastVisited = _ref[2];\n  if (index > lastVisited) {\n    var offset = 0;\n    if (lastVisited >= 0) {\n      var item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n    for (var i = lastVisited + 1; i <= index; i++) {\n      var size = sizer(i);\n      cachedItems[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n  return cachedItems[index];\n};\nvar bs = function bs(props, gridCache, low, high, offset, type) {\n  while (low <= high) {\n    var mid = low + floor((high - low) / 2);\n    var currentOffset = getItemFromCache(props, mid, gridCache, type).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return max(0, low - 1);\n};\nvar es = function es(props, gridCache, idx, offset, type) {\n  var total = type === \"column\" ? props.totalColumn : props.totalRow;\n  var exponent = 1;\n  while (idx < total && getItemFromCache(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\nvar findItem = function findItem(props, gridCache, offset, type) {\n  var _ref2 = [gridCache[type], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]],\n    cache = _ref2[0],\n    lastVisitedIndex = _ref2[1];\n  var lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref3, _ref4) {\n  var totalRow = _ref3.totalRow;\n  var estimatedRowHeight = _ref4.estimatedRowHeight,\n    lastVisitedRowIndex = _ref4.lastVisitedRowIndex,\n    row = _ref4.row;\n  var sizeOfVisitedRows = 0;\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n  if (lastVisitedRowIndex >= 0) {\n    var item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n  var unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  var sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref5, _ref6) {\n  var totalColumn = _ref5.totalColumn;\n  var column = _ref6.column,\n    estimatedColumnWidth = _ref6.estimatedColumnWidth,\n    lastVisitedColumnIndex = _ref6.lastVisitedColumnIndex;\n  var sizeOfVisitedColumns = 0;\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n  if (lastVisitedColumnIndex >= 0) {\n    var item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n  var unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  var sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\nvar ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\nvar getOffset = function getOffset(props, index, alignment, scrollOffset, cache, type, scrollBarWidth) {\n  var _ref7 = [type === \"row\" ? props.height : props.width, ACCESS_ESTIMATED_SIZE_KEY_MAP[type]],\n    size = _ref7[0],\n    estimatedSizeAssociates = _ref7[1];\n  var item = getItemFromCache(props, index, cache, type);\n  var estimatedSize = estimatedSizeAssociates(props, cache);\n  var maxOffset = max(0, min(estimatedSize - size, item.offset));\n  var minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n  switch (alignment) {\n    case START_ALIGNMENT:\n      {\n        return maxOffset;\n      }\n    case END_ALIGNMENT:\n      {\n        return minOffset;\n      }\n    case CENTERED_ALIGNMENT:\n      {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n    case AUTO_ALIGNMENT:\n    default:\n      {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n  }\n};\nvar DynamicSizeGrid = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: function getColumnPosition(props, idx, cache) {\n    var item = getItemFromCache(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: function getRowPosition(props, idx, cache) {\n    var item = getItemFromCache(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: function getColumnOffset(props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) {\n    return getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth);\n  },\n  getRowOffset: function getRowOffset(props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) {\n    return getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth);\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, cache) {\n    return findItem(props, cache, scrollLeft, \"column\");\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, cache) {\n    var item = getItemFromCache(props, startIndex, cache, \"column\");\n    var maxOffset = scrollLeft + props.width;\n    var offset = item.offset + item.size;\n    var stopIndex = startIndex;\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, startIndex, cache, \"column\").size;\n    }\n    return stopIndex;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, cache) {\n    return findItem(props, cache, scrollTop, \"row\");\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, cache) {\n    var totalRow = props.totalRow,\n      height = props.height;\n    var item = getItemFromCache(props, startIndex, cache, \"row\");\n    var maxOffset = scrollTop + height;\n    var offset = item.size + item.offset;\n    var stopIndex = startIndex;\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, cache, \"row\").size;\n    }\n    return stopIndex;\n  },\n  injectToInstance: function injectToInstance(instance, cache) {\n    var resetAfter = function resetAfter(_ref8, forceUpdate) {\n      var columnIndex = _ref8.columnIndex,\n        rowIndex = _ref8.rowIndex;\n      var _a, _b;\n      forceUpdate = isUndefined(forceUpdate) ? true : forceUpdate;\n      if (isNumber(columnIndex)) {\n        cache.value.lastVisitedColumnIndex = Math.min(cache.value.lastVisitedColumnIndex, columnIndex - 1);\n      }\n      if (isNumber(rowIndex)) {\n        cache.value.lastVisitedRowIndex = Math.min(cache.value.lastVisitedRowIndex, rowIndex - 1);\n      }\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache.value(-1, null, null);\n      if (forceUpdate) (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n    };\n    var resetAfterColumnIndex = function resetAfterColumnIndex(columnIndex, forceUpdate) {\n      resetAfter({\n        columnIndex: columnIndex\n      }, forceUpdate);\n    };\n    var resetAfterRowIndex = function resetAfterRowIndex(rowIndex, forceUpdate) {\n      resetAfter({\n        rowIndex: rowIndex\n      }, forceUpdate);\n    };\n    Object.assign(instance.proxy, {\n      resetAfterColumnIndex: resetAfterColumnIndex,\n      resetAfterRowIndex: resetAfterRowIndex,\n      resetAfter: resetAfter\n    });\n  },\n  initCache: function initCache(_ref9) {\n    var _ref9$estimatedColumn = _ref9.estimatedColumnWidth,\n      estimatedColumnWidth = _ref9$estimatedColumn === void 0 ? DEFAULT_DYNAMIC_LIST_ITEM_SIZE : _ref9$estimatedColumn,\n      _ref9$estimatedRowHei = _ref9.estimatedRowHeight,\n      estimatedRowHeight = _ref9$estimatedRowHei === void 0 ? DEFAULT_DYNAMIC_LIST_ITEM_SIZE : _ref9$estimatedRowHei;\n    var cache = {\n      column: {},\n      estimatedColumnWidth: estimatedColumnWidth,\n      estimatedRowHeight: estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: function validateProps(_ref10) {\n    var columnWidth = _ref10.columnWidth,\n      rowHeight = _ref10.rowHeight;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE, \"\\n          \\\"columnWidth\\\" must be passed as function,\\n            instead \".concat(_typeof(columnWidth), \" was given.\\n        \"));\n      }\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE, \"\\n          \\\"rowHeight\\\" must be passed as function,\\n            instead \".concat(_typeof(rowHeight), \" was given.\\n        \"));\n      }\n    }\n  }\n});\nexport { DynamicSizeGrid as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}