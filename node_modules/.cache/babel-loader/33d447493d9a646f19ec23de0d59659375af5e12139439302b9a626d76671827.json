{"ast":null,"code":"import _defineProperty from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.number.is-finite.js\";\nimport { defineComponent, computed, ref, reactive, unref, watch, onBeforeUnmount, h, withModifiers } from 'vue';\nimport { HORIZONTAL, ScrollbarDirKey, SCROLLBAR_MIN_SIZE } from '../defaults.mjs';\nimport { virtualizedScrollbarProps } from '../props.mjs';\nimport { renderThumbStyle } from '../utils.mjs';\nimport { BAR_MAP } from '../../../scrollbar/src/util.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { cAF, rAF } from '../../../../utils/raf.mjs';\nvar ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: virtualizedScrollbarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n    var GAP = computed(function () {\n      return props.startGap + props.endGap;\n    });\n    var nsVirtualScrollbar = useNamespace(\"virtual-scrollbar\");\n    var nsScrollbar = useNamespace(\"scrollbar\");\n    var trackRef = ref();\n    var thumbRef = ref();\n    var frameHandle = null;\n    var onselectstartStore = null;\n    var state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    var bar = computed(function () {\n      return BAR_MAP[props.layout];\n    });\n    var trackSize = computed(function () {\n      return props.clientSize - unref(GAP);\n    });\n    var trackStyle = computed(function () {\n      return _defineProperty(_defineProperty(_defineProperty(_defineProperty({\n        position: \"absolute\",\n        width: \"\".concat(HORIZONTAL === props.layout ? trackSize.value : props.scrollbarSize, \"px\"),\n        height: \"\".concat(HORIZONTAL === props.layout ? props.scrollbarSize : trackSize.value, \"px\")\n      }, ScrollbarDirKey[props.layout], \"2px\"), \"right\", \"2px\"), \"bottom\", \"2px\"), \"borderRadius\", \"4px\");\n    });\n    var thumbSize = computed(function () {\n      var ratio = props.ratio;\n      var clientSize = props.clientSize;\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (ratio >= 50) {\n        return ratio * clientSize / 100;\n      }\n      var SCROLLBAR_MAX_SIZE = clientSize / 3;\n      return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    var thumbStyle = computed(function () {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n      var thumb = \"\".concat(thumbSize.value, \"px\");\n      var style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    var totalSteps = computed(function () {\n      return Math.floor(props.clientSize - thumbSize.value - unref(GAP));\n    });\n    var attachEvents = function attachEvents() {\n      window.addEventListener(\"mousemove\", onMouseMove);\n      window.addEventListener(\"mouseup\", onMouseUp);\n      var thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      onselectstartStore = document.onselectstart;\n      document.onselectstart = function () {\n        return false;\n      };\n      thumbEl.addEventListener(\"touchmove\", onMouseMove, {\n        passive: true\n      });\n      thumbEl.addEventListener(\"touchend\", onMouseUp);\n    };\n    var detachEvents = function detachEvents() {\n      window.removeEventListener(\"mousemove\", onMouseMove);\n      window.removeEventListener(\"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      var thumbEl = unref(thumbRef);\n      if (!thumbEl) return;\n      thumbEl.removeEventListener(\"touchmove\", onMouseMove);\n      thumbEl.removeEventListener(\"touchend\", onMouseUp);\n    };\n    var onThumbMouseDown = function onThumbMouseDown(e) {\n      e.stopImmediatePropagation();\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n    var onMouseUp = function onMouseUp() {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n    var onMouseMove = function onMouseMove(e) {\n      var isDragging = state.isDragging;\n      if (!isDragging) return;\n      if (!thumbRef.value || !trackRef.value) return;\n      var prevPage = state[bar.value.axis];\n      if (!prevPage) return;\n      cAF(frameHandle);\n      var offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      var thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      var distance = offset - thumbClickPosition;\n      frameHandle = rAF(function () {\n        state.traveled = Math.max(props.startGap, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n    var clickTrackHandler = function clickTrackHandler(e) {\n      var offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);\n      var thumbHalf = thumbRef.value[bar.value.offset] / 2;\n      var distance = offset - thumbHalf;\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value));\n      emit(\"scroll\", distance, totalSteps.value);\n    };\n    watch(function () {\n      return props.scrollFrom;\n    }, function (v) {\n      if (state.isDragging) return;\n      state.traveled = Math.ceil(v * totalSteps.value);\n    });\n    onBeforeUnmount(function () {\n      detachEvents();\n    });\n    return function () {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        \"class\": [nsVirtualScrollbar.b(), props[\"class\"], (props.alwaysOn || state.isDragging) && \"always-on\"],\n        style: trackStyle.value,\n        onMousedown: withModifiers(clickTrackHandler, [\"stop\", \"prevent\"]),\n        onTouchstartPrevent: onThumbMouseDown\n      }, h(\"div\", {\n        ref: thumbRef,\n        \"class\": nsScrollbar.e(\"thumb\"),\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, []));\n    };\n  }\n});\nexport { ScrollBar as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}