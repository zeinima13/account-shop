{"ast":null,"code":"import _defineProperty from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.every.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/es.array.find-last.js\";\nimport \"core-js/modules/es.array.flat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.unscopables.flat.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.number.is-nan.js\";\nimport \"core-js/modules/es.object.define-properties.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.from-entries.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\nimport \"core-js/modules/es.object.get-own-property-names.js\";\nimport \"core-js/modules/es.object.is-extensible.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.set-prototype-of.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.reflect.delete-property.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.reflect.has.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.pad-start.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.every.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { shallowRef, watchEffect, readonly, unref, ref, isVue3, version, watch, customRef, getCurrentScope, onScopeDispose, effectScope, provide, inject, isRef, computed, reactive, toRefs as toRefs$1, toRef, isVue2, set as set$1, getCurrentInstance, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\nvar __defProp$9 = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = function __defNormalProp$9(obj, key, value) {\n  return key in obj ? __defProp$9(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues$9 = function __spreadValues$9(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp$b.call(b, prop)) __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols$b(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum$b.call(b, prop)) __defNormalProp$9(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps$6 = function __spreadProps$6(a, b) {\n  return __defProps$6(a, __getOwnPropDescs$6(b));\n};\nfunction computedEager(fn, options) {\n  var _a;\n  var result = shallowRef();\n  watchEffect(function () {\n    result.value = fn();\n  }, __spreadProps$6(__spreadValues$9({}, options), {\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  }));\n  return readonly(result);\n}\nvar _a;\nvar isClient = typeof window !== \"undefined\";\nvar isDef = function isDef(val) {\n  return typeof val !== \"undefined\";\n};\nvar assert = function assert(condition) {\n  var _console;\n  for (var _len = arguments.length, infos = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    infos[_key - 1] = arguments[_key];\n  }\n  if (!condition) (_console = console).warn.apply(_console, infos);\n};\nvar toString = Object.prototype.toString;\nvar isBoolean = function isBoolean(val) {\n  return typeof val === \"boolean\";\n};\nvar isFunction = function isFunction(val) {\n  return typeof val === \"function\";\n};\nvar isNumber = function isNumber(val) {\n  return typeof val === \"number\";\n};\nvar isString = function isString(val) {\n  return typeof val === \"string\";\n};\nvar isObject = function isObject(val) {\n  return toString.call(val) === \"[object Object]\";\n};\nvar isWindow = function isWindow(val) {\n  return typeof window !== \"undefined\" && toString.call(val) === \"[object Window]\";\n};\nvar now = function now() {\n  return Date.now();\n};\nvar timestamp = function timestamp() {\n  return +Date.now();\n};\nvar clamp = function clamp(n, min, max) {\n  return Math.min(max, Math.max(min, n));\n};\nvar noop = function noop() {};\nvar rand = function rand(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nvar isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);\nvar hasOwn = function hasOwn(val, key) {\n  return Object.prototype.hasOwnProperty.call(val, key);\n};\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nfunction createFilterWrapper(filter, fn) {\n  function wrapper() {\n    var _this = this;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return new Promise(function (resolve, reject) {\n      Promise.resolve(filter(function () {\n        return fn.apply(_this, args);\n      }, {\n        fn: fn,\n        thisArg: _this,\n        args: args\n      })).then(resolve)[\"catch\"](reject);\n    });\n  }\n  return wrapper;\n}\nvar bypassFilter = function bypassFilter(invoke) {\n  return invoke();\n};\nfunction debounceFilter(ms) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var timer;\n  var maxTimer;\n  var lastRejector = noop;\n  var _clearTimeout = function _clearTimeout(timer2) {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  var filter = function filter(invoke) {\n    var duration = resolveUnref(ms);\n    var maxDuration = resolveUnref(options.maxWait);\n    if (timer) _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise(function (resolve, reject) {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(function () {\n          if (timer) _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(function () {\n        if (maxTimer) _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(ms) {\n  var trailing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var leading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var rejectOnCancel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var lastExec = 0;\n  var timer;\n  var isLeading = true;\n  var lastRejector = noop;\n  var lastValue;\n  var clear = function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  var filter = function filter(_invoke) {\n    var duration = resolveUnref(ms);\n    var elapsed = Date.now() - lastExec;\n    var invoke = function invoke() {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise(function (resolve, reject) {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(function () {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer) timer = setTimeout(function () {\n      return isLeading = true;\n    }, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter() {\n  var extendFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bypassFilter;\n  var isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  var eventFilter = function eventFilter() {\n    if (isActive.value) extendFilter.apply(void 0, arguments);\n  };\n  return {\n    isActive: readonly(isActive),\n    pause: pause,\n    resume: resume,\n    eventFilter: eventFilter\n  };\n}\nfunction __onlyVue3() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"this function\";\n  if (isVue3) return;\n  throw new Error(\"[VueUse] \".concat(name, \" is only works on Vue 3.\"));\n}\nfunction __onlyVue27Plus() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"this function\";\n  if (isVue3 || version.startsWith(\"2.7.\")) return;\n  throw new Error(\"[VueUse] \".concat(name, \" is only works on Vue 2.7 or above.\"));\n}\nvar directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\nfunction promiseTimeout(ms) {\n  var throwOnTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Timeout\";\n  return new Promise(function (resolve, reject) {\n    if (throwOnTimeout) setTimeout(function () {\n      return reject(reason);\n    }, ms);else setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  var _promise;\n  function wrapper() {\n    if (!_promise) _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var _prev;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _prev = _promise;\n          _promise = void 0;\n          if (!_prev) {\n            _context.next = 5;\n            break;\n          }\n          _context.next = 5;\n          return _prev;\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj) {\n  for (var _len3 = arguments.length, props = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    props[_key3 - 1] = arguments[_key3];\n  }\n  return props.some(function (k) {\n    return k in obj;\n  });\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\") return target + delta;\n  var value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  var unit = target.slice(value.length);\n  var result = parseFloat(value) + delta;\n  if (Number.isNaN(result)) return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys) {\n  var omitUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return keys.reduce(function (n, k) {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0) n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction computedWithControl(source, fn) {\n  var v = void 0;\n  var track;\n  var trigger;\n  var dirty = ref(true);\n  var update = function update() {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, {\n    flush: \"sync\"\n  });\n  var _get = isFunction(fn) ? fn : fn.get;\n  var _set = isFunction(fn) ? void 0 : fn.set;\n  var result = customRef(function (_track, _trigger) {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get: function get() {\n        if (dirty.value) {\n          v = _get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set: function set(v2) {\n        _set == null ? void 0 : _set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result)) result.trigger = update;\n  return result;\n}\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\nfunction createEventHook() {\n  var fns = [];\n  var off = function off(fn) {\n    var index = fns.indexOf(fn);\n    if (index !== -1) fns.splice(index, 1);\n  };\n  var on = function on(fn) {\n    fns.push(fn);\n    var offFn = function offFn() {\n      return off(fn);\n    };\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  var trigger = function trigger(param) {\n    fns.forEach(function (fn) {\n      return fn(param);\n    });\n  };\n  return {\n    on: on,\n    off: off,\n    trigger: trigger\n  };\n}\nfunction createGlobalState(stateFactory) {\n  var initialized = false;\n  var state;\n  var scope = effectScope(true);\n  return function () {\n    if (!initialized) {\n      state = scope.run(stateFactory);\n      initialized = true;\n    }\n    return state;\n  };\n}\nfunction createInjectionState(composable) {\n  var key = Symbol(\"InjectionState\");\n  var useProvidingState = function useProvidingState() {\n    var state = composable.apply(void 0, arguments);\n    provide(key, state);\n    return state;\n  };\n  var useInjectedState = function useInjectedState() {\n    return inject(key);\n  };\n  return [useProvidingState, useInjectedState];\n}\nfunction createSharedComposable(composable) {\n  var subscribers = 0;\n  var state;\n  var scope;\n  var dispose = function dispose() {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(function () {\n        return composable.apply(void 0, args);\n      });\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\nfunction extendRef(ref, extend) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref2$enumerable = _ref2.enumerable,\n    enumerable = _ref2$enumerable === void 0 ? false : _ref2$enumerable,\n    _ref2$unwrap = _ref2.unwrap,\n    unwrap = _ref2$unwrap === void 0 ? true : _ref2$unwrap;\n  __onlyVue27Plus();\n  var _loop = function _loop() {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      key = _Object$entries$_i[0],\n      value = _Object$entries$_i[1];\n    if (key === \"value\") return 1; // continue\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get: function get() {\n          return value.value;\n        },\n        set: function set(v) {\n          value.value = v;\n        },\n        enumerable: enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, {\n        value: value,\n        enumerable: enumerable\n      });\n    }\n  };\n  for (var _i = 0, _Object$entries = Object.entries(extend); _i < _Object$entries.length; _i++) {\n    if (_loop()) continue;\n  }\n  return ref;\n}\nfunction get(obj, key) {\n  if (key == null) return unref(obj);\n  return unref(obj)[key];\n}\nfunction isDefined(v) {\n  return unref(v) != null;\n}\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = function __defNormalProp$8(obj, key, value) {\n  return key in obj ? __defProp$8(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues$8 = function __spreadValues$8(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp$a.call(b, prop)) __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a) {\n    var _iterator2 = _createForOfIteratorHelper(__getOwnPropSymbols$a(b)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var prop = _step2.value;\n        if (__propIsEnum$a.call(b, prop)) __defNormalProp$8(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return a;\n};\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    var clone = __spreadValues$8({}, obj);\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value: function value() {\n        var index = 0;\n        return {\n          next: function next() {\n            return {\n              value: arr[index++],\n              done: index > arr.length\n            };\n          }\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign(_toConsumableArray(arr), obj);\n  }\n}\nfunction reactify(fn, options) {\n  var unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : resolveUnref;\n  return function () {\n    var _this2 = this;\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    return computed(function () {\n      return fn.apply(_this2, args.map(function (i) {\n        return unrefFn(i);\n      }));\n    });\n  };\n}\nfunction reactifyObject(obj) {\n  var optionsOrKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var keys = [];\n  var options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    var _keys, _keys2;\n    options = optionsOrKeys;\n    var _optionsOrKeys$includ = optionsOrKeys.includeOwnProperties,\n      includeOwnProperties = _optionsOrKeys$includ === void 0 ? true : _optionsOrKeys$includ;\n    (_keys = keys).push.apply(_keys, _toConsumableArray(Object.keys(obj)));\n    if (includeOwnProperties) (_keys2 = keys).push.apply(_keys2, _toConsumableArray(Object.getOwnPropertyNames(obj)));\n  }\n  return Object.fromEntries(keys.map(function (key) {\n    var value = obj[key];\n    return [key, typeof value === \"function\" ? reactify(value.bind(obj), options) : value];\n  }));\n}\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef)) return reactive(objectRef);\n  var proxy = new Proxy({}, {\n    get: function get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set: function set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value)) objectRef.value[p].value = value;else objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty: function deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has: function has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys: function ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\nfunction reactiveOmit(obj) {\n  for (var _len6 = arguments.length, keys = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    keys[_key6 - 1] = arguments[_key6];\n  }\n  var flatKeys = keys.flat();\n  return reactiveComputed(function () {\n    return Object.fromEntries(Object.entries(toRefs$1(obj)).filter(function (e) {\n      return !flatKeys.includes(e[0]);\n    }));\n  });\n}\nfunction reactivePick(obj) {\n  for (var _len7 = arguments.length, keys = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    keys[_key7 - 1] = arguments[_key7];\n  }\n  var flatKeys = keys.flat();\n  return reactive(Object.fromEntries(flatKeys.map(function (k) {\n    return [k, toRef(obj, k)];\n  })));\n}\nfunction refAutoReset(defaultValue) {\n  var afterMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e4;\n  return customRef(function (track, trigger) {\n    var value = defaultValue;\n    var timer;\n    var resetAfter = function resetAfter() {\n      return setTimeout(function () {\n        value = defaultValue;\n        trigger();\n      }, resolveUnref(afterMs));\n    };\n    tryOnScopeDispose(function () {\n      clearTimeout(timer);\n    });\n    return {\n      get: function get() {\n        track();\n        return value;\n      },\n      set: function set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\nfunction useDebounceFn(fn) {\n  var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return createFilterWrapper(debounceFilter(ms, options), fn);\n}\nfunction refDebounced(value) {\n  var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var debounced = ref(value.value);\n  var updater = useDebounceFn(function () {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, function () {\n    return updater();\n  });\n  return debounced;\n}\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get: function get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set: function set(value) {\n      source.value = value;\n    }\n  });\n}\nfunction useThrottleFn(fn) {\n  var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n  var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var rejectOnCancel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn);\n}\nfunction refThrottled(value) {\n  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n  var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (delay <= 0) return value;\n  var throttled = ref(value.value);\n  var updater = useThrottleFn(function () {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, function () {\n    return updater();\n  });\n  return throttled;\n}\nfunction refWithControl(initial) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var source = initial;\n  var track;\n  var trigger;\n  var ref = customRef(function (_track, _trigger) {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get: function get() {\n        return _get2();\n      },\n      set: function set(v) {\n        _set2(v);\n      }\n    };\n  });\n  function _get2() {\n    var tracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (tracking) track();\n    return source;\n  }\n  function _set2(value) {\n    var triggering = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var _a, _b;\n    if (value === source) return;\n    var old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false) return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering) trigger();\n  }\n  var untrackedGet = function untrackedGet() {\n    return _get2(false);\n  };\n  var silentSet = function silentSet(v) {\n    return _set2(v, false);\n  };\n  var peek = function peek() {\n    return _get2(false);\n  };\n  var lay = function lay(v) {\n    return _set2(v, false);\n  };\n  return extendRef(ref, {\n    get: _get2,\n    set: _set2,\n    untrackedGet: untrackedGet,\n    silentSet: silentSet,\n    peek: peek,\n    lay: lay\n  }, {\n    enumerable: true\n  });\n}\nvar controlledRef = refWithControl;\nfunction resolveRef(r) {\n  return typeof r === \"function\" ? computed(r) : ref(r);\n}\nfunction set() {\n  for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    args[_key8] = arguments[_key8];\n  }\n  if (args.length === 2) {\n    var _ref3 = args[0],\n      value = args[1];\n    _ref3.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1.apply(void 0, args);\n    } else {\n      var target = args[0],\n        key = args[1],\n        _value2 = args[2];\n      target[key] = _value2;\n    }\n  }\n}\nfunction syncRef(left, right) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a, _b;\n  var _options$flush = options.flush,\n    flush = _options$flush === void 0 ? \"sync\" : _options$flush,\n    _options$deep = options.deep,\n    deep = _options$deep === void 0 ? false : _options$deep,\n    _options$immediate = options.immediate,\n    immediate = _options$immediate === void 0 ? true : _options$immediate,\n    _options$direction = options.direction,\n    direction = _options$direction === void 0 ? \"both\" : _options$direction,\n    _options$transform = options.transform,\n    transform = _options$transform === void 0 ? {} : _options$transform;\n  var watchLeft;\n  var watchRight;\n  var transformLTR = (_a = transform.ltr) != null ? _a : function (v) {\n    return v;\n  };\n  var transformRTL = (_b = transform.rtl) != null ? _b : function (v) {\n    return v;\n  };\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchLeft = watch(left, function (newValue) {\n      return right.value = transformLTR(newValue);\n    }, {\n      flush: flush,\n      deep: deep,\n      immediate: immediate\n    });\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchRight = watch(right, function (newValue) {\n      return left.value = transformRTL(newValue);\n    }, {\n      flush: flush,\n      deep: deep,\n      immediate: immediate\n    });\n  }\n  return function () {\n    watchLeft == null ? void 0 : watchLeft();\n    watchRight == null ? void 0 : watchRight();\n  };\n}\nfunction syncRefs(source, targets) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$flush2 = options.flush,\n    flush = _options$flush2 === void 0 ? \"sync\" : _options$flush2,\n    _options$deep2 = options.deep,\n    deep = _options$deep2 === void 0 ? false : _options$deep2,\n    _options$immediate2 = options.immediate,\n    immediate = _options$immediate2 === void 0 ? true : _options$immediate2;\n  if (!Array.isArray(targets)) targets = [targets];\n  return watch(source, function (newValue) {\n    return targets.forEach(function (target) {\n      return target.value = newValue;\n    });\n  }, {\n    flush: flush,\n    deep: deep,\n    immediate: immediate\n  });\n}\nvar __defProp$7 = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = function __defNormalProp$7(obj, key, value) {\n  return key in obj ? __defProp$7(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues$7 = function __spreadValues$7(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp$9.call(b, prop)) __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9) {\n    var _iterator3 = _createForOfIteratorHelper(__getOwnPropSymbols$9(b)),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var prop = _step3.value;\n        if (__propIsEnum$9.call(b, prop)) __defNormalProp$7(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps$5 = function __spreadProps$5(a, b) {\n  return __defProps$5(a, __getOwnPropDescs$5(b));\n};\nfunction toRefs(objectRef) {\n  if (!isRef(objectRef)) return toRefs$1(objectRef);\n  var result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\n  var _loop2 = function _loop2(key) {\n    result[key] = customRef(function () {\n      return {\n        get: function get() {\n          return objectRef.value[key];\n        },\n        set: function set(v) {\n          if (Array.isArray(objectRef.value)) {\n            var copy = _toConsumableArray(objectRef.value);\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            var newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), _defineProperty({}, key, v));\n            Object.setPrototypeOf(newObject, objectRef.value);\n            objectRef.value = newObject;\n          }\n        }\n      };\n    });\n  };\n  for (var key in objectRef.value) {\n    _loop2(key);\n  }\n  return result;\n}\nfunction tryOnBeforeMount(fn) {\n  var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (getCurrentInstance()) onBeforeMount(fn);else if (sync) fn();else nextTick(fn);\n}\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance()) onBeforeUnmount(fn);\n}\nfunction tryOnMounted(fn) {\n  var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (getCurrentInstance()) onMounted(fn);else if (sync) fn();else nextTick(fn);\n}\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance()) onUnmounted(fn);\n}\nfunction createUntil(r) {\n  var isNot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  function toMatch(condition) {\n    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref4$flush = _ref4.flush,\n      flush = _ref4$flush === void 0 ? \"sync\" : _ref4$flush,\n      _ref4$deep = _ref4.deep,\n      deep = _ref4$deep === void 0 ? false : _ref4$deep,\n      timeout = _ref4.timeout,\n      throwOnTimeout = _ref4.throwOnTimeout;\n    var stop = null;\n    var watcher = new Promise(function (resolve) {\n      stop = watch(r, function (v) {\n        if (condition(v) !== isNot) {\n          stop == null ? void 0 : stop();\n          resolve(v);\n        }\n      }, {\n        flush: flush,\n        deep: deep,\n        immediate: true\n      });\n    });\n    var promises = [watcher];\n    if (timeout != null) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(function () {\n        return resolveUnref(r);\n      })[\"finally\"](function () {\n        return stop == null ? void 0 : stop();\n      }));\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value)) return toMatch(function (v) {\n      return v === value;\n    }, options);\n    var _ref5 = options != null ? options : {},\n      _ref5$flush = _ref5.flush,\n      flush = _ref5$flush === void 0 ? \"sync\" : _ref5$flush,\n      _ref5$deep = _ref5.deep,\n      deep = _ref5$deep === void 0 ? false : _ref5$deep,\n      timeout = _ref5.timeout,\n      throwOnTimeout = _ref5.throwOnTimeout;\n    var stop = null;\n    var watcher = new Promise(function (resolve) {\n      stop = watch([r, value], function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n          v1 = _ref7[0],\n          v2 = _ref7[1];\n        if (isNot !== (v1 === v2)) {\n          stop == null ? void 0 : stop();\n          resolve(v1);\n        }\n      }, {\n        flush: flush,\n        deep: deep,\n        immediate: true\n      });\n    });\n    var promises = [watcher];\n    if (timeout != null) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(function () {\n        return resolveUnref(r);\n      })[\"finally\"](function () {\n        stop == null ? void 0 : stop();\n        return resolveUnref(r);\n      }));\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch(function (v) {\n      return Boolean(v);\n    }, options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch(function (v) {\n      var array = Array.from(v);\n      return array.includes(value) || array.includes(resolveUnref(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var options = arguments.length > 1 ? arguments[1] : undefined;\n    var count = -1;\n    return toMatch(function () {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(resolveUnref(r))) {\n    var instance = {\n      toMatch: toMatch,\n      toContains: toContains,\n      changed: changed,\n      changedTimes: changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    var _instance = {\n      toMatch: toMatch,\n      toBe: toBe,\n      toBeTruthy: toBeTruthy,\n      toBeNull: toBeNull,\n      toBeNaN: toBeNaN,\n      toBeUndefined: toBeUndefined,\n      changed: changed,\n      changedTimes: changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return _instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\nfunction useArrayEvery(list, fn) {\n  return computed(function () {\n    return resolveUnref(list).every(function (element, index, array) {\n      return fn(resolveUnref(element), index, array);\n    });\n  });\n}\nfunction useArrayFilter(list, fn) {\n  return computed(function () {\n    return resolveUnref(list).map(function (i) {\n      return resolveUnref(i);\n    }).filter(fn);\n  });\n}\nfunction useArrayFind(list, fn) {\n  return computed(function () {\n    return resolveUnref(resolveUnref(list).find(function (element, index, array) {\n      return fn(resolveUnref(element), index, array);\n    }));\n  });\n}\nfunction useArrayFindIndex(list, fn) {\n  return computed(function () {\n    return resolveUnref(list).findIndex(function (element, index, array) {\n      return fn(resolveUnref(element), index, array);\n    });\n  });\n}\nfunction findLast(arr, cb) {\n  var index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr)) return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(function () {\n    return resolveUnref(!Array.prototype.findLast ? findLast(resolveUnref(list), function (element, index, array) {\n      return fn(resolveUnref(element), index, array);\n    }) : resolveUnref(list).findLast(function (element, index, array) {\n      return fn(resolveUnref(element), index, array);\n    }));\n  });\n}\nfunction useArrayJoin(list, separator) {\n  return computed(function () {\n    return resolveUnref(list).map(function (i) {\n      return resolveUnref(i);\n    }).join(resolveUnref(separator));\n  });\n}\nfunction useArrayMap(list, fn) {\n  return computed(function () {\n    return resolveUnref(list).map(function (i) {\n      return resolveUnref(i);\n    }).map(fn);\n  });\n}\nfunction useArrayReduce(list, reducer) {\n  for (var _len9 = arguments.length, args = new Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {\n    args[_key9 - 2] = arguments[_key9];\n  }\n  var reduceCallback = function reduceCallback(sum, value, index) {\n    return reducer(resolveUnref(sum), resolveUnref(value), index);\n  };\n  return computed(function () {\n    var resolved = resolveUnref(list);\n    return args.length ? resolved.reduce(reduceCallback, resolveUnref(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\nfunction useArraySome(list, fn) {\n  return computed(function () {\n    return resolveUnref(list).some(function (element, index, array) {\n      return fn(resolveUnref(element), index, array);\n    });\n  });\n}\nfunction useArrayUnique(list) {\n  return computed(function () {\n    return _toConsumableArray(new Set(resolveUnref(list).map(function (element) {\n      return resolveUnref(element);\n    })));\n  });\n}\nfunction useCounter() {\n  var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var count = ref(initialValue);\n  var _options$max = options.max,\n    max = _options$max === void 0 ? Infinity : _options$max,\n    _options$min = options.min,\n    min = _options$min === void 0 ? -Infinity : _options$min;\n  var inc = function inc() {\n    var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return count.value = Math.min(max, count.value + delta);\n  };\n  var dec = function dec() {\n    var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return count.value = Math.max(min, count.value - delta);\n  };\n  var get = function get() {\n    return count.value;\n  };\n  var set = function set(val) {\n    return count.value = Math.max(min, Math.min(max, val));\n  };\n  var reset = function reset() {\n    var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialValue;\n    initialValue = val;\n    return set(val);\n  };\n  return {\n    count: count,\n    inc: inc,\n    dec: dec,\n    get: get,\n    set: set,\n    reset: reset\n  };\n}\nvar REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nvar REGEX_FORMAT = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nvar defaultMeridiem = function defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  var m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod) m = m.split(\"\").reduce(function (acc, curr) {\n    return acc += \"\".concat(curr, \".\");\n  }, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n};\nvar formatDate = function formatDate(date, formatStr) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a;\n  var years = date.getFullYear();\n  var month = date.getMonth();\n  var days = date.getDate();\n  var hours = date.getHours();\n  var minutes = date.getMinutes();\n  var seconds = date.getSeconds();\n  var milliseconds = date.getMilliseconds();\n  var day = date.getDay();\n  var meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  var matches = {\n    YY: function YY() {\n      return String(years).slice(-2);\n    },\n    YYYY: function YYYY() {\n      return years;\n    },\n    M: function M() {\n      return month + 1;\n    },\n    MM: function MM() {\n      return \"\".concat(month + 1).padStart(2, \"0\");\n    },\n    MMM: function MMM() {\n      return date.toLocaleDateString(options.locales, {\n        month: \"short\"\n      });\n    },\n    MMMM: function MMMM() {\n      return date.toLocaleDateString(options.locales, {\n        month: \"long\"\n      });\n    },\n    D: function D() {\n      return String(days);\n    },\n    DD: function DD() {\n      return \"\".concat(days).padStart(2, \"0\");\n    },\n    H: function H() {\n      return String(hours);\n    },\n    HH: function HH() {\n      return \"\".concat(hours).padStart(2, \"0\");\n    },\n    h: function h() {\n      return \"\".concat(hours % 12 || 12).padStart(1, \"0\");\n    },\n    hh: function hh() {\n      return \"\".concat(hours % 12 || 12).padStart(2, \"0\");\n    },\n    m: function m() {\n      return String(minutes);\n    },\n    mm: function mm() {\n      return \"\".concat(minutes).padStart(2, \"0\");\n    },\n    s: function s() {\n      return String(seconds);\n    },\n    ss: function ss() {\n      return \"\".concat(seconds).padStart(2, \"0\");\n    },\n    SSS: function SSS() {\n      return \"\".concat(milliseconds).padStart(3, \"0\");\n    },\n    d: function d() {\n      return day;\n    },\n    dd: function dd() {\n      return date.toLocaleDateString(options.locales, {\n        weekday: \"narrow\"\n      });\n    },\n    ddd: function ddd() {\n      return date.toLocaleDateString(options.locales, {\n        weekday: \"short\"\n      });\n    },\n    dddd: function dddd() {\n      return date.toLocaleDateString(options.locales, {\n        weekday: \"long\"\n      });\n    },\n    A: function A() {\n      return meridiem(hours, minutes);\n    },\n    AA: function AA() {\n      return meridiem(hours, minutes, false, true);\n    },\n    a: function a() {\n      return meridiem(hours, minutes, true);\n    },\n    aa: function aa() {\n      return meridiem(hours, minutes, true, true);\n    }\n  };\n  return formatStr.replace(REGEX_FORMAT, function (match, $1) {\n    return $1 || matches[match]();\n  });\n};\nvar normalizeDate = function normalizeDate(date) {\n  if (date === null) return new Date(NaN);\n  if (date === void 0) return new Date();\n  if (date instanceof Date) return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    var d = date.match(REGEX_PARSE);\n    if (d) {\n      var m = d[2] - 1 || 0;\n      var ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n};\nfunction useDateFormat(date) {\n  var formatStr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"HH:mm:ss\";\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return computed(function () {\n    return formatDate(normalizeDate(resolveUnref(date)), resolveUnref(formatStr), options);\n  });\n}\nfunction useIntervalFn(cb) {\n  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e3;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$immediate3 = options.immediate,\n    immediate = _options$immediate3 === void 0 ? true : _options$immediate3,\n    _options$immediateCal = options.immediateCallback,\n    immediateCallback = _options$immediateCal === void 0 ? false : _options$immediateCal;\n  var timer = null;\n  var isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    var intervalValue = resolveUnref(interval);\n    if (intervalValue <= 0) return;\n    isActive.value = true;\n    if (immediateCallback) cb();\n    clean();\n    timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient) resume();\n  if (isRef(interval) || isFunction(interval)) {\n    var stopWatch = watch(interval, function () {\n      if (isActive.value && isClient) resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive: isActive,\n    pause: pause,\n    resume: resume\n  };\n}\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = function __defNormalProp$6(obj, key, value) {\n  return key in obj ? __defProp$6(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues$6 = function __spreadValues$6(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp$8.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8) {\n    var _iterator4 = _createForOfIteratorHelper(__getOwnPropSymbols$8(b)),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var prop = _step4.value;\n        if (__propIsEnum$8.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n  return a;\n};\nfunction useInterval() {\n  var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1e3;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$controls = options.controls,\n    exposeControls = _options$controls === void 0 ? false : _options$controls,\n    _options$immediate4 = options.immediate,\n    immediate = _options$immediate4 === void 0 ? true : _options$immediate4,\n    callback = options.callback;\n  var counter = ref(0);\n  var update = function update() {\n    return counter.value += 1;\n  };\n  var reset = function reset() {\n    counter.value = 0;\n  };\n  var controls = useIntervalFn(callback ? function () {\n    update();\n    callback(counter.value);\n  } : update, interval, {\n    immediate: immediate\n  });\n  if (exposeControls) {\n    return __spreadValues$6({\n      counter: counter,\n      reset: reset\n    }, controls);\n  } else {\n    return counter;\n  }\n}\nfunction useLastChanged(source) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a;\n  var ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(source, function () {\n    return ms.value = timestamp();\n  }, options);\n  return ms;\n}\nfunction useTimeoutFn(cb, interval) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$immediate5 = options.immediate,\n    immediate = _options$immediate5 === void 0 ? true : _options$immediate5;\n  var isPending = ref(false);\n  var timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start() {\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n    clear();\n    isPending.value = true;\n    timer = setTimeout(function () {\n      isPending.value = false;\n      timer = null;\n      cb.apply(void 0, args);\n    }, resolveUnref(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient) start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start: start,\n    stop: stop\n  };\n}\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = function __defNormalProp$5(obj, key, value) {\n  return key in obj ? __defProp$5(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues$5 = function __spreadValues$5(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp$7.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$7) {\n    var _iterator5 = _createForOfIteratorHelper(__getOwnPropSymbols$7(b)),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var prop = _step5.value;\n        if (__propIsEnum$7.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n  return a;\n};\nfunction useTimeout() {\n  var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1e3;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$controls2 = options.controls,\n    exposeControls = _options$controls2 === void 0 ? false : _options$controls2,\n    callback = options.callback;\n  var controls = useTimeoutFn(callback != null ? callback : noop, interval, options);\n  var ready = computed(function () {\n    return !controls.isPending.value;\n  });\n  if (exposeControls) {\n    return __spreadValues$5({\n      ready: ready\n    }, controls);\n  } else {\n    return ready;\n  }\n}\nfunction useToNumber(value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$method = options.method,\n    method = _options$method === void 0 ? \"parseFloat\" : _options$method,\n    radix = options.radix,\n    nanToZero = options.nanToZero;\n  return computed(function () {\n    var resolved = resolveUnref(value);\n    if (typeof resolved === \"string\") resolved = Number[method](resolved, radix);\n    if (nanToZero && isNaN(resolved)) resolved = 0;\n    return resolved;\n  });\n}\nfunction useToString(value) {\n  return computed(function () {\n    return \"\".concat(resolveUnref(value));\n  });\n}\nfunction useToggle() {\n  var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$truthyValue = options.truthyValue,\n    truthyValue = _options$truthyValue === void 0 ? true : _options$truthyValue,\n    _options$falsyValue = options.falsyValue,\n    falsyValue = _options$falsyValue === void 0 ? false : _options$falsyValue;\n  var valueIsRef = isRef(initialValue);\n  var _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      var truthy = resolveUnref(truthyValue);\n      _value.value = _value.value === truthy ? resolveUnref(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef) return toggle;else return [_value, toggle];\n}\nfunction watchArray(source, cb, options) {\n  var oldList = (options == null ? void 0 : options.immediate) ? [] : _toConsumableArray(source instanceof Function ? source() : Array.isArray(source) ? source : unref(source));\n  return watch(source, function (newList, _, onCleanup) {\n    var oldListRemains = new Array(oldList.length);\n    var added = [];\n    var _iterator6 = _createForOfIteratorHelper(newList),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var obj = _step6.value;\n        var found = false;\n        for (var i = 0; i < oldList.length; i++) {\n          if (!oldListRemains[i] && obj === oldList[i]) {\n            oldListRemains[i] = true;\n            found = true;\n            break;\n          }\n        }\n        if (!found) added.push(obj);\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    var removed = oldList.filter(function (_2, i) {\n      return !oldListRemains[i];\n    });\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = _toConsumableArray(newList);\n  }, options);\n}\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __objRest$5 = function __objRest$5(source, exclude) {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$6) {\n    var _iterator7 = _createForOfIteratorHelper(__getOwnPropSymbols$6(source)),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var prop = _step7.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n  }\n  return target;\n};\nfunction watchWithFilter(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a = options,\n    _a$eventFilter = _a.eventFilter,\n    eventFilter = _a$eventFilter === void 0 ? bypassFilter : _a$eventFilter,\n    watchOptions = __objRest$5(_a, [\"eventFilter\"]);\n  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);\n}\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __objRest$4 = function __objRest$4(source, exclude) {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$5) {\n    var _iterator8 = _createForOfIteratorHelper(__getOwnPropSymbols$5(source)),\n      _step8;\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var prop = _step8.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n  }\n  return target;\n};\nfunction watchAtMost(source, cb, options) {\n  var _a = options,\n    count = _a.count,\n    watchOptions = __objRest$4(_a, [\"count\"]);\n  var current = ref(0);\n  var stop = watchWithFilter(source, function () {\n    current.value += 1;\n    if (current.value >= resolveUnref(count)) nextTick(function () {\n      return stop();\n    });\n    cb.apply(void 0, arguments);\n  }, watchOptions);\n  return {\n    count: current,\n    stop: stop\n  };\n}\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = function __defNormalProp$4(obj, key, value) {\n  return key in obj ? __defProp$4(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues$4 = function __spreadValues$4(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp$4.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4) {\n    var _iterator9 = _createForOfIteratorHelper(__getOwnPropSymbols$4(b)),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var prop = _step9.value;\n        if (__propIsEnum$4.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps$4 = function __spreadProps$4(a, b) {\n  return __defProps$4(a, __getOwnPropDescs$4(b));\n};\nvar __objRest$3 = function __objRest$3(source, exclude) {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$4) {\n    var _iterator10 = _createForOfIteratorHelper(__getOwnPropSymbols$4(source)),\n      _step10;\n    try {\n      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n        var prop = _step10.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator10.e(err);\n    } finally {\n      _iterator10.f();\n    }\n  }\n  return target;\n};\nfunction watchDebounced(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a = options,\n    _a$debounce = _a.debounce,\n    debounce = _a$debounce === void 0 ? 0 : _a$debounce,\n    _a$maxWait = _a.maxWait,\n    maxWait = _a$maxWait === void 0 ? void 0 : _a$maxWait,\n    watchOptions = __objRest$3(_a, [\"debounce\", \"maxWait\"]);\n  return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$4({}, watchOptions), {\n    eventFilter: debounceFilter(debounce, {\n      maxWait: maxWait\n    })\n  }));\n}\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = function __defNormalProp$3(obj, key, value) {\n  return key in obj ? __defProp$3(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues$3 = function __spreadValues$3(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp$3.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3) {\n    var _iterator11 = _createForOfIteratorHelper(__getOwnPropSymbols$3(b)),\n      _step11;\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var prop = _step11.value;\n        if (__propIsEnum$3.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps$3 = function __spreadProps$3(a, b) {\n  return __defProps$3(a, __getOwnPropDescs$3(b));\n};\nvar __objRest$2 = function __objRest$2(source, exclude) {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$3) {\n    var _iterator12 = _createForOfIteratorHelper(__getOwnPropSymbols$3(source)),\n      _step12;\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var prop = _step12.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n  }\n  return target;\n};\nfunction watchIgnorable(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a = options,\n    _a$eventFilter2 = _a.eventFilter,\n    eventFilter = _a$eventFilter2 === void 0 ? bypassFilter : _a$eventFilter2,\n    watchOptions = __objRest$2(_a, [\"eventFilter\"]);\n  var filteredCb = createFilterWrapper(eventFilter, cb);\n  var ignoreUpdates;\n  var ignorePrevAsyncUpdates;\n  var stop;\n  if (watchOptions.flush === \"sync\") {\n    var ignore = ref(false);\n    ignorePrevAsyncUpdates = function ignorePrevAsyncUpdates() {};\n    ignoreUpdates = function ignoreUpdates(updater) {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(source, function () {\n      if (!ignore.value) filteredCb.apply(void 0, arguments);\n    }, watchOptions);\n  } else {\n    var disposables = [];\n    var ignoreCounter = ref(0);\n    var syncCounter = ref(0);\n    ignorePrevAsyncUpdates = function ignorePrevAsyncUpdates() {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(watch(source, function () {\n      syncCounter.value++;\n    }, __spreadProps$3(__spreadValues$3({}, watchOptions), {\n      flush: \"sync\"\n    })));\n    ignoreUpdates = function ignoreUpdates(updater) {\n      var syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(watch(source, function () {\n      var ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n      ignoreCounter.value = 0;\n      syncCounter.value = 0;\n      if (ignore) return;\n      filteredCb.apply(void 0, arguments);\n    }, watchOptions));\n    stop = function stop() {\n      disposables.forEach(function (fn) {\n        return fn();\n      });\n    };\n  }\n  return {\n    stop: stop,\n    ignoreUpdates: ignoreUpdates,\n    ignorePrevAsyncUpdates: ignorePrevAsyncUpdates\n  };\n}\nfunction watchOnce(source, cb, options) {\n  var stop = watch(source, function () {\n    nextTick(function () {\n      return stop();\n    });\n    return cb.apply(void 0, arguments);\n  }, options);\n}\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = function __defNormalProp$2(obj, key, value) {\n  return key in obj ? __defProp$2(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues$2 = function __spreadValues$2(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2) {\n    var _iterator13 = _createForOfIteratorHelper(__getOwnPropSymbols$2(b)),\n      _step13;\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var prop = _step13.value;\n        if (__propIsEnum$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps$2 = function __spreadProps$2(a, b) {\n  return __defProps$2(a, __getOwnPropDescs$2(b));\n};\nvar __objRest$1 = function __objRest$1(source, exclude) {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2) {\n    var _iterator14 = _createForOfIteratorHelper(__getOwnPropSymbols$2(source)),\n      _step14;\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var prop = _step14.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n  }\n  return target;\n};\nfunction watchPausable(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a = options,\n    filter = _a.eventFilter,\n    watchOptions = __objRest$1(_a, [\"eventFilter\"]);\n  var _pausableFilter = pausableFilter(filter),\n    eventFilter = _pausableFilter.eventFilter,\n    pause = _pausableFilter.pause,\n    resume = _pausableFilter.resume,\n    isActive = _pausableFilter.isActive;\n  var stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {\n    eventFilter: eventFilter\n  }));\n  return {\n    stop: stop,\n    pause: pause,\n    resume: resume,\n    isActive: isActive\n  };\n}\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = function __defNormalProp$1(obj, key, value) {\n  return key in obj ? __defProp$1(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues$1 = function __spreadValues$1(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1) {\n    var _iterator15 = _createForOfIteratorHelper(__getOwnPropSymbols$1(b)),\n      _step15;\n    try {\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        var prop = _step15.value;\n        if (__propIsEnum$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps$1 = function __spreadProps$1(a, b) {\n  return __defProps$1(a, __getOwnPropDescs$1(b));\n};\nvar __objRest = function __objRest(source, exclude) {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$1) {\n    var _iterator16 = _createForOfIteratorHelper(__getOwnPropSymbols$1(source)),\n      _step16;\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var prop = _step16.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n  }\n  return target;\n};\nfunction watchThrottled(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a = options,\n    _a$throttle = _a.throttle,\n    throttle = _a$throttle === void 0 ? 0 : _a$throttle,\n    _a$trailing = _a.trailing,\n    trailing = _a$trailing === void 0 ? true : _a$trailing,\n    _a$leading = _a.leading,\n    leading = _a$leading === void 0 ? true : _a$leading,\n    watchOptions = __objRest(_a, [\"throttle\", \"trailing\", \"leading\"]);\n  return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {\n    eventFilter: throttleFilter(throttle, trailing, leading)\n  }));\n}\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) {\n    var _iterator17 = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step17;\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var prop = _step17.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\nfunction watchTriggerable(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var cleanupFn;\n  function onEffect() {\n    if (!cleanupFn) return;\n    var fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  var _cb = function _cb(value, oldValue) {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  var res = watchIgnorable(source, _cb, options);\n  var ignoreUpdates = res.ignoreUpdates;\n  var trigger = function trigger() {\n    var res2;\n    ignoreUpdates(function () {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return __spreadProps(__spreadValues({}, res), {\n    trigger: trigger\n  });\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources)) return sources;\n  if (Array.isArray(sources)) return sources.map(function (item) {\n    return getOneWatchSource(item);\n  });\n  return getOneWatchSource(sources);\n}\nfunction getOneWatchSource(source) {\n  return typeof source === \"function\" ? source() : unref(source);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(function () {\n    return void 0;\n  }) : void 0;\n}\nfunction whenever(source, cb, options) {\n  return watch(source, function (v, ov, onInvalidate) {\n    if (v) cb(v, ov, onInvalidate);\n  }, options);\n}\nexport { __onlyVue27Plus, __onlyVue3, assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isIOS, isNumber, isObject, isString, isWindow, makeDestructurable, noop, normalizeDate, now, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchIgnorable, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}