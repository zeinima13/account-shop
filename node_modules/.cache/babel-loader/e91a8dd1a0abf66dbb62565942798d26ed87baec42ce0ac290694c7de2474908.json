{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _callSuper from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _defineProperty from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _arrayInstrumentation;\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.to-reversed.js\";\nimport \"core-js/modules/es.array.to-sorted.js\";\nimport \"core-js/modules/es.array.to-spliced.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.get-own-property-names.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.object.is-extensible.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.delete-property.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.reflect.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.has.js\";\nimport \"core-js/modules/es.reflect.own-keys.js\";\nimport \"core-js/modules/es.reflect.set.js\";\nimport \"core-js/modules/es.regexp.flags.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.sub.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.weak-set.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n* @vue/reactivity v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { hasChanged, extend, isArray, isIntegerKey, isSymbol, isMap, hasOwn, isObject, makeMap, toRawType, capitalize, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, NOOP, remove } from '@vue/shared';\nfunction warn(msg) {\n  var _console;\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  (_console = console).warn.apply(_console, [\"[Vue warn] \".concat(msg)].concat(args));\n}\nvar activeEffectScope;\nvar EffectScope = /*#__PURE__*/function () {\n  function EffectScope() {\n    var detached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    _classCallCheck(this, EffectScope);\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n  return _createClass(EffectScope, [{\n    key: \"active\",\n    get: function get() {\n      return this._active;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this._active) {\n        this._isPaused = true;\n        var i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].pause();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].pause();\n        }\n      }\n    }\n    /**\n     * Resumes the effect scope, including all child scopes and effects.\n     */\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._active) {\n        if (this._isPaused) {\n          this._isPaused = false;\n          var i, l;\n          if (this.scopes) {\n            for (i = 0, l = this.scopes.length; i < l; i++) {\n              this.scopes[i].resume();\n            }\n          }\n          for (i = 0, l = this.effects.length; i < l; i++) {\n            this.effects[i].resume();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"run\",\n    value: function run(fn) {\n      if (this._active) {\n        var currentEffectScope = activeEffectScope;\n        try {\n          activeEffectScope = this;\n          return fn();\n        } finally {\n          activeEffectScope = currentEffectScope;\n        }\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        warn(\"cannot run an inactive effect scope.\");\n      }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n  }, {\n    key: \"on\",\n    value: function on() {\n      activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n  }, {\n    key: \"off\",\n    value: function off() {\n      activeEffectScope = this.parent;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(fromParent) {\n      if (this._active) {\n        this._active = false;\n        var i, l;\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].stop();\n        }\n        this.effects.length = 0;\n        for (i = 0, l = this.cleanups.length; i < l; i++) {\n          this.cleanups[i]();\n        }\n        this.cleanups.length = 0;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].stop(true);\n          }\n          this.scopes.length = 0;\n        }\n        if (!this.detached && this.parent && !fromParent) {\n          var last = this.parent.scopes.pop();\n          if (last && last !== this) {\n            this.parent.scopes[this.index] = last;\n            last.index = this.index;\n          }\n        }\n        this.parent = void 0;\n      }\n    }\n  }]);\n}();\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  var failSilently = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\"onScopeDispose() is called when there is no active effect scope to be associated with.\");\n  }\n}\nvar activeSub;\nvar EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\"\n};\nvar pausedQueueEffects = /* @__PURE__ */new WeakSet();\nvar ReactiveEffect = /*#__PURE__*/function () {\n  function ReactiveEffect(fn) {\n    _classCallCheck(this, ReactiveEffect);\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  return _createClass(ReactiveEffect, [{\n    key: \"pause\",\n    value: function pause() {\n      this.flags |= 64;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this.flags & 64) {\n        this.flags &= ~64;\n        if (pausedQueueEffects.has(this)) {\n          pausedQueueEffects[\"delete\"](this);\n          this.trigger();\n        }\n      }\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"notify\",\n    value: function notify() {\n      if (this.flags & 2 && !(this.flags & 32)) {\n        return;\n      }\n      if (!(this.flags & 8)) {\n        batch(this);\n      }\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (!(this.flags & 1)) {\n        return this.fn();\n      }\n      this.flags |= 2;\n      cleanupEffect(this);\n      prepareDeps(this);\n      var prevEffect = activeSub;\n      var prevShouldTrack = shouldTrack;\n      activeSub = this;\n      shouldTrack = true;\n      try {\n        return this.fn();\n      } finally {\n        if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n          warn(\"Active effect was not restored correctly - this is likely a Vue internal bug.\");\n        }\n        cleanupDeps(this);\n        activeSub = prevEffect;\n        shouldTrack = prevShouldTrack;\n        this.flags &= ~2;\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.flags & 1) {\n        for (var link = this.deps; link; link = link.nextDep) {\n          removeSub(link);\n        }\n        this.deps = this.depsTail = void 0;\n        cleanupEffect(this);\n        this.onStop && this.onStop();\n        this.flags &= ~1;\n      }\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger() {\n      if (this.flags & 64) {\n        pausedQueueEffects.add(this);\n      } else if (this.scheduler) {\n        this.scheduler();\n      } else {\n        this.runIfDirty();\n      }\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"runIfDirty\",\n    value: function runIfDirty() {\n      if (isDirty(this)) {\n        this.run();\n      }\n    }\n  }, {\n    key: \"dirty\",\n    get: function get() {\n      return isDirty(this);\n    }\n  }]);\n}();\nvar batchDepth = 0;\nvar batchedSub;\nvar batchedComputed;\nfunction batch(sub) {\n  var isComputed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    var e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      var next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      e = next;\n    }\n  }\n  var error;\n  while (batchedSub) {\n    var _e = batchedSub;\n    batchedSub = void 0;\n    while (_e) {\n      var _next = _e.next;\n      _e.next = void 0;\n      _e.flags &= ~8;\n      if (_e.flags & 1) {\n        try {\n          ;\n          _e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      _e = _next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (var link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  var head;\n  var tail = sub.depsTail;\n  var link = tail;\n  while (link) {\n    var prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (var link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= ~16;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  var dep = computed.dep;\n  computed.flags |= 2;\n  if (dep.version > 0 && !computed.isSSR && computed.deps && !isDirty(computed)) {\n    computed.flags &= ~2;\n    return;\n  }\n  var prevSub = activeSub;\n  var prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    var value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= ~2;\n  }\n}\nfunction removeSub(link) {\n  var soft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dep = link.dep,\n    prevSub = link.prevSub,\n    nextSub = link.nextSub;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= ~4;\n      for (var l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && ! --dep.sc && dep.map) {\n    dep.map[\"delete\"](dep.key);\n  }\n}\nfunction removeDep(link) {\n  var prevDep = link.prevDep,\n    nextDep = link.nextDep;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  var e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  var runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nvar shouldTrack = true;\nvar trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  var last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn) {\n  var failSilently = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\"onEffectCleanup() was called when there was no active effect to associate with.\");\n  }\n}\nfunction cleanupEffect(e) {\n  var cleanup = e.cleanup;\n  e.cleanup = void 0;\n  if (cleanup) {\n    var prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\nvar globalVersion = 0;\nvar Link = /*#__PURE__*/_createClass(function Link(sub, dep) {\n  _classCallCheck(this, Link);\n  this.sub = sub;\n  this.dep = dep;\n  this.version = dep.version;\n  this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n});\nvar Dep = /*#__PURE__*/function () {\n  function Dep(computed) {\n    _classCallCheck(this, Dep);\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  return _createClass(Dep, [{\n    key: \"track\",\n    value: function track(debugInfo) {\n      if (!activeSub || !shouldTrack || activeSub === this.computed) {\n        return;\n      }\n      var link = this.activeLink;\n      if (link === void 0 || link.sub !== activeSub) {\n        link = this.activeLink = new Link(activeSub, this);\n        if (!activeSub.deps) {\n          activeSub.deps = activeSub.depsTail = link;\n        } else {\n          link.prevDep = activeSub.depsTail;\n          activeSub.depsTail.nextDep = link;\n          activeSub.depsTail = link;\n        }\n        addSub(link);\n      } else if (link.version === -1) {\n        link.version = this.version;\n        if (link.nextDep) {\n          var next = link.nextDep;\n          next.prevDep = link.prevDep;\n          if (link.prevDep) {\n            link.prevDep.nextDep = next;\n          }\n          link.prevDep = activeSub.depsTail;\n          link.nextDep = void 0;\n          activeSub.depsTail.nextDep = link;\n          activeSub.depsTail = link;\n          if (activeSub.deps === link) {\n            activeSub.deps = next;\n          }\n        }\n      }\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n        activeSub.onTrack(extend({\n          effect: activeSub\n        }, debugInfo));\n      }\n      return link;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(debugInfo) {\n      this.version++;\n      globalVersion++;\n      this.notify(debugInfo);\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(debugInfo) {\n      startBatch();\n      try {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          for (var head = this.subsHead; head; head = head.nextSub) {\n            if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n              head.sub.onTrigger(extend({\n                effect: head.sub\n              }, debugInfo));\n            }\n          }\n        }\n        for (var link = this.subs; link; link = link.prevSub) {\n          if (link.sub.notify()) {\n            ;\n            link.sub.dep.notify();\n          }\n        }\n      } finally {\n        endBatch();\n      }\n    }\n  }]);\n}();\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    var _computed = link.dep.computed;\n    if (_computed && !link.dep.subs) {\n      _computed.flags |= 4 | 16;\n      for (var l = _computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    var currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nvar targetMap = /* @__PURE__ */new WeakMap();\nvar ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\");\nvar MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\");\nvar ARRAY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\");\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    var depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */new Map());\n    }\n    var dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target: target,\n        type: type,\n        key: key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  var depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  var run = function run(dep) {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target: target,\n          type: type,\n          key: key,\n          newValue: newValue,\n          oldValue: oldValue,\n          oldTarget: oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    var targetIsArray = isArray(target);\n    var isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      var newLength = Number(newValue);\n      depsMap.forEach(function (dep, key2) {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  var depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\nfunction reactiveReadArray(array) {\n  var raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nvar arrayInstrumentations = (_arrayInstrumentation = {\n  __proto__: null\n}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_arrayInstrumentation, Symbol.iterator, function () {\n  return iterator(this, Symbol.iterator, toReactive);\n}), \"concat\", function concat() {\n  var _reactiveReadArray;\n  for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n  return (_reactiveReadArray = reactiveReadArray(this)).concat.apply(_reactiveReadArray, _toConsumableArray(args.map(function (x) {\n    return isArray(x) ? reactiveReadArray(x) : x;\n  })));\n}), \"entries\", function entries() {\n  return iterator(this, \"entries\", function (value) {\n    value[1] = toReactive(value[1]);\n    return value;\n  });\n}), \"every\", function every(fn, thisArg) {\n  return apply(this, \"every\", fn, thisArg, void 0, arguments);\n}), \"filter\", function filter(fn, thisArg) {\n  return apply(this, \"filter\", fn, thisArg, function (v) {\n    return v.map(toReactive);\n  }, arguments);\n}), \"find\", function find(fn, thisArg) {\n  return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n}), \"findIndex\", function findIndex(fn, thisArg) {\n  return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n}), \"findLast\", function findLast(fn, thisArg) {\n  return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n}), \"findLastIndex\", function findLastIndex(fn, thisArg) {\n  return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n}), \"forEach\", function forEach(fn, thisArg) {\n  return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n}), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_arrayInstrumentation, \"includes\", function includes() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n  return searchProxy(this, \"includes\", args);\n}), \"indexOf\", function indexOf() {\n  for (var _len4 = arguments.length, args = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n  return searchProxy(this, \"indexOf\", args);\n}), \"join\", function join(separator) {\n  return reactiveReadArray(this).join(separator);\n}), \"lastIndexOf\", function lastIndexOf() {\n  for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {\n    args[_key6] = arguments[_key6];\n  }\n  return searchProxy(this, \"lastIndexOf\", args);\n}), \"map\", function map(fn, thisArg) {\n  return apply(this, \"map\", fn, thisArg, void 0, arguments);\n}), \"pop\", function pop() {\n  return noTracking(this, \"pop\");\n}), \"push\", function push() {\n  for (var _len6 = arguments.length, args = new Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {\n    args[_key7] = arguments[_key7];\n  }\n  return noTracking(this, \"push\", args);\n}), \"reduce\", function reduce(fn) {\n  for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key8 = 1; _key8 < _len7; _key8++) {\n    args[_key8 - 1] = arguments[_key8];\n  }\n  return _reduce(this, \"reduce\", fn, args);\n}), \"reduceRight\", function reduceRight(fn) {\n  for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key9 = 1; _key9 < _len8; _key9++) {\n    args[_key9 - 1] = arguments[_key9];\n  }\n  return _reduce(this, \"reduceRight\", fn, args);\n}), \"shift\", function shift() {\n  return noTracking(this, \"shift\");\n}), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_arrayInstrumentation, \"some\", function some(fn, thisArg) {\n  return apply(this, \"some\", fn, thisArg, void 0, arguments);\n}), \"splice\", function splice() {\n  for (var _len9 = arguments.length, args = new Array(_len9), _key10 = 0; _key10 < _len9; _key10++) {\n    args[_key10] = arguments[_key10];\n  }\n  return noTracking(this, \"splice\", args);\n}), \"toReversed\", function toReversed() {\n  return reactiveReadArray(this).toReversed();\n}), \"toSorted\", function toSorted(comparer) {\n  return reactiveReadArray(this).toSorted(comparer);\n}), \"toSpliced\", function toSpliced() {\n  var _reactiveReadArray2;\n  return (_reactiveReadArray2 = reactiveReadArray(this)).toSpliced.apply(_reactiveReadArray2, arguments);\n}), \"unshift\", function unshift() {\n  for (var _len10 = arguments.length, args = new Array(_len10), _key11 = 0; _key11 < _len10; _key11++) {\n    args[_key11] = arguments[_key11];\n  }\n  return noTracking(this, \"unshift\", args);\n}), \"values\", function values() {\n  return iterator(this, \"values\", toReactive);\n}));\nfunction iterator(self, method, wrapValue) {\n  var arr = shallowReadArray(self);\n  var iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = function () {\n      var result = iter._next();\n      if (result.value) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nvar arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  var arr = shallowReadArray(self);\n  var needsWrap = arr !== self && !isShallow(self);\n  var methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    var result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  var wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function wrappedFn(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function wrappedFn(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  var result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction _reduce(self, method, fn, args) {\n  var arr = shallowReadArray(self);\n  var wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function wrappedFn(acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function wrappedFn(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method].apply(arr, [wrappedFn].concat(_toConsumableArray(args)));\n}\nfunction searchProxy(self, method, args) {\n  var arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  var res = arr[method].apply(arr, _toConsumableArray(args));\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method].apply(arr, _toConsumableArray(args));\n  }\n  return res;\n}\nfunction noTracking(self, method) {\n  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  pauseTracking();\n  startBatch();\n  var res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\nvar isNonTrackableKeys = /* @__PURE__ */makeMap(\"__proto__,__v_isRef,__isVue\");\nvar builtInSymbols = new Set(/* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(function (key) {\n  return key !== \"arguments\" && key !== \"caller\";\n}).map(function (key) {\n  return Symbol[key];\n}).filter(isSymbol));\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  var obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nvar BaseReactiveHandler = /*#__PURE__*/function () {\n  function BaseReactiveHandler() {\n    var _isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var _isShallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    _classCallCheck(this, BaseReactiveHandler);\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  return _createClass(BaseReactiveHandler, [{\n    key: \"get\",\n    value: function get(target, key, receiver) {\n      if (key === \"__v_skip\") return target[\"__v_skip\"];\n      var isReadonly2 = this._isReadonly,\n        isShallow2 = this._isShallow;\n      if (key === \"__v_isReactive\") {\n        return !isReadonly2;\n      } else if (key === \"__v_isReadonly\") {\n        return isReadonly2;\n      } else if (key === \"__v_isShallow\") {\n        return isShallow2;\n      } else if (key === \"__v_raw\") {\n        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) ||\n        // receiver is not the reactive proxy, but has the same prototype\n        // this means the receiver is a user proxy of the reactive proxy\n        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n          return target;\n        }\n        return;\n      }\n      var targetIsArray = isArray(target);\n      if (!isReadonly2) {\n        var fn;\n        if (targetIsArray && (fn = arrayInstrumentations[key])) {\n          return fn;\n        }\n        if (key === \"hasOwnProperty\") {\n          return hasOwnProperty;\n        }\n      }\n      var res = Reflect.get(target, key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver);\n      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n        return res;\n      }\n      if (!isReadonly2) {\n        track(target, \"get\", key);\n      }\n      if (isShallow2) {\n        return res;\n      }\n      if (isRef(res)) {\n        return targetIsArray && isIntegerKey(key) ? res : res.value;\n      }\n      if (isObject(res)) {\n        return isReadonly2 ? readonly(res) : reactive(res);\n      }\n      return res;\n    }\n  }]);\n}();\nvar MutableReactiveHandler = /*#__PURE__*/function (_BaseReactiveHandler) {\n  function MutableReactiveHandler() {\n    var isShallow2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    _classCallCheck(this, MutableReactiveHandler);\n    return _callSuper(this, MutableReactiveHandler, [false, isShallow2]);\n  }\n  _inherits(MutableReactiveHandler, _BaseReactiveHandler);\n  return _createClass(MutableReactiveHandler, [{\n    key: \"set\",\n    value: function set(target, key, value, receiver) {\n      var oldValue = target[key];\n      if (!this._isShallow) {\n        var isOldValueReadonly = isReadonly(oldValue);\n        if (!isShallow(value) && !isReadonly(value)) {\n          oldValue = toRaw(oldValue);\n          value = toRaw(value);\n        }\n        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n          if (isOldValueReadonly) {\n            return false;\n          } else {\n            oldValue.value = value;\n            return true;\n          }\n        }\n      }\n      var hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n      var result = Reflect.set(target, key, value, isRef(target) ? target : receiver);\n      if (target === toRaw(receiver)) {\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"deleteProperty\",\n    value: function deleteProperty(target, key) {\n      var hadKey = hasOwn(target, key);\n      var oldValue = target[key];\n      var result = Reflect.deleteProperty(target, key);\n      if (result && hadKey) {\n        trigger(target, \"delete\", key, void 0, oldValue);\n      }\n      return result;\n    }\n  }, {\n    key: \"has\",\n    value: function has(target, key) {\n      var result = Reflect.has(target, key);\n      if (!isSymbol(key) || !builtInSymbols.has(key)) {\n        track(target, \"has\", key);\n      }\n      return result;\n    }\n  }, {\n    key: \"ownKeys\",\n    value: function ownKeys(target) {\n      track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\n      return Reflect.ownKeys(target);\n    }\n  }]);\n}(BaseReactiveHandler);\nvar ReadonlyReactiveHandler = /*#__PURE__*/function (_BaseReactiveHandler2) {\n  function ReadonlyReactiveHandler() {\n    var isShallow2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    _classCallCheck(this, ReadonlyReactiveHandler);\n    return _callSuper(this, ReadonlyReactiveHandler, [true, isShallow2]);\n  }\n  _inherits(ReadonlyReactiveHandler, _BaseReactiveHandler2);\n  return _createClass(ReadonlyReactiveHandler, [{\n    key: \"set\",\n    value: function set(target, key) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        warn(\"Set operation on key \\\"\".concat(String(key), \"\\\" failed: target is readonly.\"), target);\n      }\n      return true;\n    }\n  }, {\n    key: \"deleteProperty\",\n    value: function deleteProperty(target, key) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        warn(\"Delete operation on key \\\"\".concat(String(key), \"\\\" failed: target is readonly.\"), target);\n      }\n      return true;\n    }\n  }]);\n}(BaseReactiveHandler);\nvar mutableHandlers = /* @__PURE__ */new MutableReactiveHandler();\nvar readonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler();\nvar shallowReactiveHandlers = /* @__PURE__ */new MutableReactiveHandler(true);\nvar shallowReadonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler(true);\nvar toShallow = function toShallow(value) {\n  return value;\n};\nvar getProto = function getProto(v) {\n  return Reflect.getPrototypeOf(v);\n};\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function () {\n    var target = this[\"__v_raw\"];\n    var rawTarget = toRaw(target);\n    var targetIsMap = isMap(rawTarget);\n    var isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    var isKeyOnly = method === \"keys\" && targetIsMap;\n    var innerIterator = target[method].apply(target, arguments);\n    var wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return _defineProperty({\n      // iterator protocol\n      next: function next() {\n        var _innerIterator$next = innerIterator.next(),\n          value = _innerIterator$next.value,\n          done = _innerIterator$next.done;\n        return done ? {\n          value: value,\n          done: done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done: done\n        };\n      }\n    }, Symbol.iterator, function () {\n      return this;\n    });\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function () {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      var key = (arguments.length <= 0 ? undefined : arguments[0]) ? \"on key \\\"\".concat(arguments.length <= 0 ? undefined : arguments[0], \"\\\" \") : \"\";\n      warn(\"\".concat(capitalize(type), \" operation \").concat(key, \"failed: target is readonly.\"), toRaw(this));\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  var instrumentations = {\n    get: function get(key) {\n      var target = this[\"__v_raw\"];\n      var rawTarget = toRaw(target);\n      var rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      var _getProto = getProto(rawTarget),\n        has = _getProto.has;\n      var wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      var target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return Reflect.get(target, \"size\", target);\n    },\n    has: function has(key) {\n      var target = this[\"__v_raw\"];\n      var rawTarget = toRaw(target);\n      var rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach: function forEach(callback, thisArg) {\n      var observed = this;\n      var target = observed[\"__v_raw\"];\n      var rawTarget = toRaw(target);\n      var wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach(function (value, key) {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend(instrumentations, readonly ? {\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    \"delete\": createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\")\n  } : {\n    add: function add(value) {\n      if (!shallow && !isShallow(value) && !isReadonly(value)) {\n        value = toRaw(value);\n      }\n      var target = toRaw(this);\n      var proto = getProto(target);\n      var hadKey = proto.has.call(target, value);\n      if (!hadKey) {\n        target.add(value);\n        trigger(target, \"add\", value, value);\n      }\n      return this;\n    },\n    set: function set(key, value) {\n      if (!shallow && !isShallow(value) && !isReadonly(value)) {\n        value = toRaw(value);\n      }\n      var target = toRaw(this);\n      var _getProto2 = getProto(target),\n        has = _getProto2.has,\n        get = _getProto2.get;\n      var hadKey = has.call(target, key);\n      if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        checkIdentityKeys(target, has, key);\n      }\n      var oldValue = get.call(target, key);\n      target.set(key, value);\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n      return this;\n    },\n    \"delete\": function _delete(key) {\n      var target = toRaw(this);\n      var _getProto3 = getProto(target),\n        has = _getProto3.has,\n        get = _getProto3.get;\n      var hadKey = has.call(target, key);\n      if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        checkIdentityKeys(target, has, key);\n      }\n      var oldValue = get ? get.call(target, key) : void 0;\n      var result = target[\"delete\"](key);\n      if (hadKey) {\n        trigger(target, \"delete\", key, void 0, oldValue);\n      }\n      return result;\n    },\n    clear: function clear() {\n      var target = toRaw(this);\n      var hadItems = target.size !== 0;\n      var oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n      var result = target.clear();\n      if (hadItems) {\n        trigger(target, \"clear\", void 0, void 0, oldTarget);\n      }\n      return result;\n    }\n  });\n  var iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach(function (method) {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  var instrumentations = createInstrumentations(isReadonly2, shallow);\n  return function (target, key, receiver) {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nvar mutableCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, false)\n};\nvar shallowCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, true)\n};\nvar readonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, false)\n};\nvar shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  var rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    var type = toRawType(target);\n    warn(\"Reactive \".concat(type, \" contains both the raw and reactive versions of the same object\").concat(type === \"Map\" ? \" as keys\" : \"\", \", which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.\"));\n  }\n}\nvar reactiveMap = /* @__PURE__ */new WeakMap();\nvar shallowReactiveMap = /* @__PURE__ */new WeakMap();\nvar readonlyMap = /* @__PURE__ */new WeakMap();\nvar shallowReadonlyMap = /* @__PURE__ */new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"value cannot be made \".concat(isReadonly2 ? \"readonly\" : \"reactive\", \": \").concat(String(target)));\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  var existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  var targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  var proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  var raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nvar toReactive = function toReactive(value) {\n  return isObject(value) ? reactive(value) : value;\n};\nvar toReadonly = function toReadonly(value) {\n  return isObject(value) ? readonly(value) : value;\n};\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nvar RefImpl = /*#__PURE__*/function () {\n  function RefImpl(value, isShallow2) {\n    _classCallCheck(this, RefImpl);\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  return _createClass(RefImpl, [{\n    key: \"value\",\n    get: function get() {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.track({\n          target: this,\n          type: \"get\",\n          key: \"value\"\n        });\n      } else {\n        this.dep.track();\n      }\n      return this._value;\n    },\n    set: function set(newValue) {\n      var oldValue = this._rawValue;\n      var useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n      newValue = useDirectValue ? newValue : toRaw(newValue);\n      if (hasChanged(newValue, oldValue)) {\n        this._rawValue = newValue;\n        this._value = useDirectValue ? newValue : toReactive(newValue);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          this.dep.trigger({\n            target: this,\n            type: \"set\",\n            key: \"value\",\n            newValue: newValue,\n            oldValue: oldValue\n          });\n        } else {\n          this.dep.trigger();\n        }\n      }\n    }\n  }]);\n}();\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nvar shallowUnwrapHandlers = {\n  get: function get(target, key, receiver) {\n    return key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver));\n  },\n  set: function set(target, key, value, receiver) {\n    var oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nvar CustomRefImpl = /*#__PURE__*/function () {\n  function CustomRefImpl(factory) {\n    _classCallCheck(this, CustomRefImpl);\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    var dep = this.dep = new Dep();\n    var _factory = factory(dep.track.bind(dep), dep.trigger.bind(dep)),\n      get = _factory.get,\n      set = _factory.set;\n    this._get = get;\n    this._set = set;\n  }\n  return _createClass(CustomRefImpl, [{\n    key: \"value\",\n    get: function get() {\n      return this._value = this._get();\n    },\n    set: function set(newVal) {\n      this._set(newVal);\n    }\n  }]);\n}();\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(\"toRefs() expects a reactive object but received a plain one.\");\n  }\n  var ret = isArray(object) ? new Array(object.length) : {};\n  for (var key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nvar ObjectRefImpl = /*#__PURE__*/function () {\n  function ObjectRefImpl(_object, _key, _defaultValue) {\n    _classCallCheck(this, ObjectRefImpl);\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n  }\n  return _createClass(ObjectRefImpl, [{\n    key: \"value\",\n    get: function get() {\n      var val = this._object[this._key];\n      return this._value = val === void 0 ? this._defaultValue : val;\n    },\n    set: function set(newVal) {\n      this._object[this._key] = newVal;\n    }\n  }, {\n    key: \"dep\",\n    get: function get() {\n      return getDepFromReactive(toRaw(this._object), this._key);\n    }\n  }]);\n}();\nvar GetterRefImpl = /*#__PURE__*/function () {\n  function GetterRefImpl(_getter) {\n    _classCallCheck(this, GetterRefImpl);\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  return _createClass(GetterRefImpl, [{\n    key: \"value\",\n    get: function get() {\n      return this._value = this._getter();\n    }\n  }]);\n}();\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  var val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\nvar ComputedRefImpl = /*#__PURE__*/function () {\n  function ComputedRefImpl(fn, setter, isSSR) {\n    _classCallCheck(this, ComputedRefImpl);\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  return _createClass(ComputedRefImpl, [{\n    key: \"notify\",\n    value: function notify() {\n      this.flags |= 16;\n      if (!(this.flags & 8) &&\n      // avoid infinite self recursion\n      activeSub !== this) {\n        batch(this, true);\n        return true;\n      } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      var link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      }) : this.dep.track();\n      refreshComputed(this);\n      if (link) {\n        link.version = this.dep.version;\n      }\n      return this._value;\n    },\n    set: function set(newValue) {\n      if (this.setter) {\n        this.setter(newValue);\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        warn(\"Write operation failed: computed value is readonly\");\n      }\n    }\n  }]);\n}();\nfunction computed(getterOrOptions, debugOptions) {\n  var isSSR = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var getter;\n  var setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  var cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\nvar TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nvar TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nvar ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\nvar WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nvar INITIAL_WATCHER_VALUE = {};\nvar cleanupMap = /* @__PURE__ */new WeakMap();\nvar activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn) {\n  var failSilently = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var owner = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : activeWatcher;\n  if (owner) {\n    var cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\"onWatcherCleanup() was called when there was no active watcher to associate with.\");\n  }\n}\nfunction watch(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJ;\n  var immediate = options.immediate,\n    deep = options.deep,\n    once = options.once,\n    scheduler = options.scheduler,\n    augmentJob = options.augmentJob,\n    call = options.call;\n  var warnInvalidSource = function warnInvalidSource(s) {\n    (options.onWarn || warn)(\"Invalid watch source: \", s, \"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.\");\n  };\n  var reactiveGetter = function reactiveGetter(source2) {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0) return traverse(source2, 1);\n    return traverse(source2);\n  };\n  var effect;\n  var getter;\n  var cleanup;\n  var boundCleanup;\n  var forceTrigger = false;\n  var isMultiSource = false;\n  if (isRef(source)) {\n    getter = function getter() {\n      return source.value;\n    };\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = function getter() {\n      return reactiveGetter(source);\n    };\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(function (s) {\n      return isReactive(s) || isShallow(s);\n    });\n    getter = function getter() {\n      return source.map(function (s) {\n        if (isRef(s)) {\n          return s.value;\n        } else if (isReactive(s)) {\n          return reactiveGetter(s);\n        } else if (isFunction(s)) {\n          return call ? call(s, 2) : s();\n        } else {\n          !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n        }\n      });\n    };\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? function () {\n        return call(source, 2);\n      } : source;\n    } else {\n      getter = function getter() {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        var currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    var baseGetter = getter;\n    var depth = deep === true ? Infinity : deep;\n    getter = function getter() {\n      return traverse(baseGetter(), depth);\n    };\n  }\n  var scope = getCurrentScope();\n  var watchHandle = function watchHandle() {\n    effect.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    var _cb = cb;\n    cb = function cb() {\n      _cb.apply(void 0, arguments);\n      watchHandle();\n    };\n  }\n  var oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  var job = function job(immediateFirstRun) {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      var newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some(function (v, i) {\n        return hasChanged(v, oldValue[i]);\n      }) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        var currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          var args = [newValue,\n          // pass undefined as the old value when it's changed for the first time\n          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, boundCleanup];\n          call ? call(cb, 3, args) :\n          // @ts-expect-error\n          cb.apply(void 0, args);\n          oldValue = newValue;\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? function () {\n    return scheduler(job, false);\n  } : job;\n  boundCleanup = function boundCleanup(fn) {\n    return onWatcherCleanup(fn, false, effect);\n  };\n  cleanup = effect.onStop = function () {\n    var cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        var _iterator = _createForOfIteratorHelper(cleanups),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var cleanup2 = _step.value;\n            cleanup2();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      cleanupMap[\"delete\"](effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  var seen = arguments.length > 2 ? arguments[2] : undefined;\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach(function (v) {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (var key in value) {\n      traverse(value[key], depth, seen);\n    }\n    var _iterator2 = _createForOfIteratorHelper(Object.getOwnPropertySymbols(value)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _key12 = _step2.value;\n        if (Object.prototype.propertyIsEnumerable.call(value, _key12)) {\n          traverse(value[_key12], depth, seen);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return value;\n}\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}