{"ast":null,"code":"import _objectSpread from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport { ref, onMounted, onBeforeUnmount } from 'vue';\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens.mjs';\nimport { isElement } from '../../../utils/types.mjs';\nimport { isFocusable } from '../../../utils/dom/aria.mjs';\nvar focusReason = ref();\nvar lastUserFocusTimestamp = ref(0);\nvar lastAutomatedFocusTimestamp = ref(0);\nvar focusReasonUserCount = 0;\nvar obtainAllFocusableElements = function obtainAllFocusableElements(element) {\n  var nodes = [];\n  var walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: function acceptNode(node) {\n      var isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n};\nvar getVisibleElement = function getVisibleElement(elements, container) {\n  var _iterator = _createForOfIteratorHelper(elements),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var element = _step.value;\n      if (!isHidden(element, container)) return element;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\nvar isHidden = function isHidden(element, container) {\n  if (process.env.NODE_ENV === \"test\") return false;\n  if (getComputedStyle(element).visibility === \"hidden\") return true;\n  while (element) {\n    if (container && element === container) return false;\n    if (getComputedStyle(element).display === \"none\") return true;\n    element = element.parentElement;\n  }\n  return false;\n};\nvar getEdges = function getEdges(container) {\n  var focusable = obtainAllFocusableElements(container);\n  var first = getVisibleElement(focusable, container);\n  var last = getVisibleElement(focusable.reverse(), container);\n  return [first, last];\n};\nvar isSelectable = function isSelectable(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n};\nvar tryFocus = function tryFocus(element, shouldSelect) {\n  if (element && element.focus) {\n    var prevFocusedElement = document.activeElement;\n    var cleanup = false;\n    if (isElement(element) && !isFocusable(element) && !element.getAttribute(\"tabindex\")) {\n      element.setAttribute(\"tabindex\", \"-1\");\n      cleanup = true;\n    }\n    element.focus({\n      preventScroll: true\n    });\n    lastAutomatedFocusTimestamp.value = window.performance.now();\n    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {\n      element.select();\n    }\n    if (isElement(element) && cleanup) {\n      element.removeAttribute(\"tabindex\");\n    }\n  }\n};\nfunction removeFromStack(list, item) {\n  var copy = _toConsumableArray(list);\n  var idx = list.indexOf(item);\n  if (idx !== -1) {\n    copy.splice(idx, 1);\n  }\n  return copy;\n}\nvar createFocusableStack = function createFocusableStack() {\n  var stack = [];\n  var push = function push(layer) {\n    var currentLayer = stack[0];\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause();\n    }\n    stack = removeFromStack(stack, layer);\n    stack.unshift(layer);\n  };\n  var remove = function remove(layer) {\n    var _a, _b;\n    stack = removeFromStack(stack, layer);\n    (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);\n  };\n  return {\n    push: push,\n    remove: remove\n  };\n};\nvar focusFirstDescendant = function focusFirstDescendant(elements) {\n  var shouldSelect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var prevFocusedElement = document.activeElement;\n  var _iterator2 = _createForOfIteratorHelper(elements),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var element = _step2.value;\n      tryFocus(element, shouldSelect);\n      if (document.activeElement !== prevFocusedElement) return;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\nvar focusableStack = createFocusableStack();\nvar isFocusCausedByUserEvent = function isFocusCausedByUserEvent() {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;\n};\nvar notifyFocusReasonPointer = function notifyFocusReasonPointer() {\n  focusReason.value = \"pointer\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nvar notifyFocusReasonKeydown = function notifyFocusReasonKeydown() {\n  focusReason.value = \"keyboard\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nvar useFocusReason = function useFocusReason() {\n  onMounted(function () {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.addEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.addEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n    focusReasonUserCount++;\n  });\n  onBeforeUnmount(function () {\n    focusReasonUserCount--;\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.removeEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.removeEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n  });\n  return {\n    focusReason: focusReason,\n    lastUserFocusTimestamp: lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp: lastAutomatedFocusTimestamp\n  };\n};\nvar createFocusOutPreventedEvent = function createFocusOutPreventedEvent(detail) {\n  return new CustomEvent(FOCUSOUT_PREVENTED, _objectSpread(_objectSpread({}, FOCUSOUT_PREVENTED_OPTS), {}, {\n    detail: detail\n  }));\n};\nexport { createFocusOutPreventedEvent, focusFirstDescendant, focusableStack, getEdges, getVisibleElement, isFocusCausedByUserEvent, isHidden, obtainAllFocusableElements, tryFocus, useFocusReason };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}