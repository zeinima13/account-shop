{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.number.parse-float.js\";\nimport { shallowRef, ref } from 'vue';\nimport { getStyle, setStyle } from '../../../../utils/dom/style.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { isUndefined } from '../../../../utils/types.mjs';\nfunction useDragTag(_ref) {\n  var wrapperRef = _ref.wrapperRef,\n    handleDragged = _ref.handleDragged,\n    afterDragged = _ref.afterDragged;\n  var ns = useNamespace(\"input-tag\");\n  var dropIndicatorRef = shallowRef();\n  var showDropIndicator = ref(false);\n  var draggingIndex;\n  var draggingTag;\n  var dropIndex;\n  var dropType;\n  function getTagClassName(index) {\n    return \".\".concat(ns.e(\"inner\"), \" .\").concat(ns.namespace.value, \"-tag:nth-child(\").concat(index + 1, \")\");\n  }\n  function handleDragStart(event, index) {\n    draggingIndex = index;\n    draggingTag = wrapperRef.value.querySelector(getTagClassName(index));\n    if (draggingTag) {\n      draggingTag.style.opacity = \"0.5\";\n    }\n    event.dataTransfer.effectAllowed = \"move\";\n  }\n  function handleDragOver(event, index) {\n    dropIndex = index;\n    event.preventDefault();\n    event.dataTransfer.dropEffect = \"move\";\n    if (isUndefined(draggingIndex) || draggingIndex === index) {\n      showDropIndicator.value = false;\n      return;\n    }\n    var dropPosition = wrapperRef.value.querySelector(getTagClassName(index)).getBoundingClientRect();\n    var dropPrev = !(draggingIndex + 1 === index);\n    var dropNext = !(draggingIndex - 1 === index);\n    var distance = event.clientX - dropPosition.left;\n    var prevPercent = dropPrev ? dropNext ? 0.5 : 1 : -1;\n    var nextPercent = dropNext ? dropPrev ? 0.5 : 0 : 1;\n    if (distance <= dropPosition.width * prevPercent) {\n      dropType = \"before\";\n    } else if (distance > dropPosition.width * nextPercent) {\n      dropType = \"after\";\n    } else {\n      dropType = void 0;\n    }\n    var innerEl = wrapperRef.value.querySelector(\".\".concat(ns.e(\"inner\")));\n    var innerPosition = innerEl.getBoundingClientRect();\n    var gap = Number.parseFloat(getStyle(innerEl, \"gap\")) / 2;\n    var indicatorTop = dropPosition.top - innerPosition.top;\n    var indicatorLeft = -9999;\n    if (dropType === \"before\") {\n      indicatorLeft = Math.max(dropPosition.left - innerPosition.left - gap, Math.floor(-gap / 2));\n    } else if (dropType === \"after\") {\n      var left = dropPosition.right - innerPosition.left;\n      indicatorLeft = left + (innerPosition.width === left ? Math.floor(gap / 2) : gap);\n    }\n    setStyle(dropIndicatorRef.value, {\n      top: \"\".concat(indicatorTop, \"px\"),\n      left: \"\".concat(indicatorLeft, \"px\")\n    });\n    showDropIndicator.value = !!dropType;\n  }\n  function handleDragEnd(event) {\n    event.preventDefault();\n    if (draggingTag) {\n      draggingTag.style.opacity = \"\";\n    }\n    if (dropType && !isUndefined(draggingIndex) && !isUndefined(dropIndex) && draggingIndex !== dropIndex) {\n      handleDragged(draggingIndex, dropIndex, dropType);\n    }\n    showDropIndicator.value = false;\n    draggingIndex = void 0;\n    draggingTag = null;\n    dropIndex = void 0;\n    dropType = void 0;\n    afterDragged == null ? void 0 : afterDragged();\n  }\n  return {\n    dropIndicatorRef: dropIndicatorRef,\n    showDropIndicator: showDropIndicator,\n    handleDragStart: handleDragStart,\n    handleDragOver: handleDragOver,\n    handleDragEnd: handleDragEnd\n  };\n}\nexport { useDragTag };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}