{"ast":null,"code":"import _objectSpread from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.number.parse-int.js\";\nimport { defineComponent, getCurrentInstance, ref, computed, unref, onMounted, nextTick, resolveDynamicComponent, h, Fragment } from 'vue';\nimport { useEventListener, isClient } from '@vueuse/core';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { useGridWheel } from '../hooks/use-grid-wheel.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport { virtualizedGridProps } from '../props.mjs';\nimport { getScrollDir, getRTLOffsetType, isRTL } from '../utils.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, FORWARD, BACKWARD, AUTO_ALIGNMENT, RTL, RTL_OFFSET_POS_ASC, RTL_OFFSET_NAG, RTL_OFFSET_POS_DESC } from '../defaults.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { isNumber } from '../../../../utils/types.mjs';\nimport { getScrollBarWidth } from '../../../../utils/dom/scroll.mjs';\nimport { isString, hasOwn } from '@vue/shared';\nvar createGrid = function createGrid(_ref) {\n  var name = _ref.name,\n    clearCache = _ref.clearCache,\n    getColumnPosition = _ref.getColumnPosition,\n    getColumnStartIndexForOffset = _ref.getColumnStartIndexForOffset,\n    getColumnStopIndexForStartIndex = _ref.getColumnStopIndexForStartIndex,\n    getEstimatedTotalHeight = _ref.getEstimatedTotalHeight,\n    getEstimatedTotalWidth = _ref.getEstimatedTotalWidth,\n    getColumnOffset = _ref.getColumnOffset,\n    getRowOffset = _ref.getRowOffset,\n    getRowPosition = _ref.getRowPosition,\n    getRowStartIndexForOffset = _ref.getRowStartIndexForOffset,\n    getRowStopIndexForStartIndex = _ref.getRowStopIndexForStartIndex,\n    initCache = _ref.initCache,\n    injectToInstance = _ref.injectToInstance,\n    validateProps = _ref.validateProps;\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup: function setup(props, _ref2) {\n      var emit = _ref2.emit,\n        expose = _ref2.expose,\n        slots = _ref2.slots;\n      var ns = useNamespace(\"vl\");\n      validateProps(props);\n      var instance = getCurrentInstance();\n      var cache = ref(initCache(props, instance));\n      injectToInstance == null ? void 0 : injectToInstance(instance, cache);\n      var windowRef = ref();\n      var hScrollbar = ref();\n      var vScrollbar = ref();\n      var innerRef = ref(null);\n      var states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      var getItemStyleCache = useCache();\n      var parsedHeight = computed(function () {\n        return Number.parseInt(\"\".concat(props.height), 10);\n      });\n      var parsedWidth = computed(function () {\n        return Number.parseInt(\"\".concat(props.width), 10);\n      });\n      var columnsToRender = computed(function () {\n        var totalColumn = props.totalColumn,\n          totalRow = props.totalRow,\n          columnCache = props.columnCache;\n        var _unref = unref(states),\n          isScrolling = _unref.isScrolling,\n          xAxisScrollDir = _unref.xAxisScrollDir,\n          scrollLeft = _unref.scrollLeft;\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        var startIndex = getColumnStartIndexForOffset(props, scrollLeft, unref(cache));\n        var stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, unref(cache));\n        var cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        var cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      var rowsToRender = computed(function () {\n        var totalColumn = props.totalColumn,\n          totalRow = props.totalRow,\n          rowCache = props.rowCache;\n        var _unref2 = unref(states),\n          isScrolling = _unref2.isScrolling,\n          yAxisScrollDir = _unref2.yAxisScrollDir,\n          scrollTop = _unref2.scrollTop;\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        var startIndex = getRowStartIndexForOffset(props, scrollTop, unref(cache));\n        var stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, unref(cache));\n        var cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        var cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      var estimatedTotalHeight = computed(function () {\n        return getEstimatedTotalHeight(props, unref(cache));\n      });\n      var estimatedTotalWidth = computed(function () {\n        return getEstimatedTotalWidth(props, unref(cache));\n      });\n      var windowStyle = computed(function () {\n        var _a;\n        return [{\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        }, {\n          direction: props.direction,\n          height: isNumber(props.height) ? \"\".concat(props.height, \"px\") : props.height,\n          width: isNumber(props.width) ? \"\".concat(props.width, \"px\") : props.width\n        }, (_a = props.style) != null ? _a : {}];\n      });\n      var innerStyle = computed(function () {\n        var width = \"\".concat(unref(estimatedTotalWidth), \"px\");\n        var height = \"\".concat(unref(estimatedTotalHeight), \"px\");\n        return {\n          height: height,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: width\n        };\n      });\n      var emitEvents = function emitEvents() {\n        var totalColumn = props.totalColumn,\n          totalRow = props.totalRow;\n        if (totalColumn > 0 && totalRow > 0) {\n          var _unref3 = unref(columnsToRender),\n            _unref4 = _slicedToArray(_unref3, 4),\n            columnCacheStart = _unref4[0],\n            columnCacheEnd = _unref4[1],\n            columnVisibleStart = _unref4[2],\n            columnVisibleEnd = _unref4[3];\n          var _unref5 = unref(rowsToRender),\n            _unref6 = _slicedToArray(_unref5, 4),\n            rowCacheStart = _unref6[0],\n            rowCacheEnd = _unref6[1],\n            rowVisibleStart = _unref6[2],\n            rowVisibleEnd = _unref6[3];\n          emit(ITEM_RENDER_EVT, {\n            columnCacheStart: columnCacheStart,\n            columnCacheEnd: columnCacheEnd,\n            rowCacheStart: rowCacheStart,\n            rowCacheEnd: rowCacheEnd,\n            columnVisibleStart: columnVisibleStart,\n            columnVisibleEnd: columnVisibleEnd,\n            rowVisibleStart: rowVisibleStart,\n            rowVisibleEnd: rowVisibleEnd\n          });\n        }\n        var _unref7 = unref(states),\n          scrollLeft = _unref7.scrollLeft,\n          scrollTop = _unref7.scrollTop,\n          updateRequested = _unref7.updateRequested,\n          xAxisScrollDir = _unref7.xAxisScrollDir,\n          yAxisScrollDir = _unref7.yAxisScrollDir;\n        emit(SCROLL_EVT, {\n          xAxisScrollDir: xAxisScrollDir,\n          scrollLeft: scrollLeft,\n          yAxisScrollDir: yAxisScrollDir,\n          scrollTop: scrollTop,\n          updateRequested: updateRequested\n        });\n      };\n      var onScroll = function onScroll(e) {\n        var _e$currentTarget = e.currentTarget,\n          clientHeight = _e$currentTarget.clientHeight,\n          clientWidth = _e$currentTarget.clientWidth,\n          scrollHeight = _e$currentTarget.scrollHeight,\n          scrollLeft = _e$currentTarget.scrollLeft,\n          scrollTop = _e$currentTarget.scrollTop,\n          scrollWidth = _e$currentTarget.scrollWidth;\n        var _states = unref(states);\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n        var _scrollLeft = scrollLeft;\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: true,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(function () {\n          return resetIsScrolling();\n        });\n        onUpdated();\n        emitEvents();\n      };\n      var onVerticalScroll = function onVerticalScroll(distance, totalSteps) {\n        var height = unref(parsedHeight);\n        var offset = (estimatedTotalHeight.value - height) / totalSteps * distance;\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)\n        });\n      };\n      var onHorizontalScroll = function onHorizontalScroll(distance, totalSteps) {\n        var width = unref(parsedWidth);\n        var offset = (estimatedTotalWidth.value - width) / totalSteps * distance;\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)\n        });\n      };\n      var _useGridWheel = useGridWheel({\n          atXStartEdge: computed(function () {\n            return states.value.scrollLeft <= 0;\n          }),\n          atXEndEdge: computed(function () {\n            return states.value.scrollLeft >= estimatedTotalWidth.value - unref(parsedWidth);\n          }),\n          atYStartEdge: computed(function () {\n            return states.value.scrollTop <= 0;\n          }),\n          atYEndEdge: computed(function () {\n            return states.value.scrollTop >= estimatedTotalHeight.value - unref(parsedHeight);\n          })\n        }, function (x, y) {\n          var _a, _b, _c, _d;\n          (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);\n          (_d = (_c = vScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);\n          var width = unref(parsedWidth);\n          var height = unref(parsedHeight);\n          scrollTo({\n            scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),\n            scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)\n          });\n        }),\n        onWheel = _useGridWheel.onWheel;\n      useEventListener(windowRef, \"wheel\", onWheel, {\n        passive: false\n      });\n      var scrollTo = function scrollTo(_ref3) {\n        var _ref3$scrollLeft = _ref3.scrollLeft,\n          scrollLeft = _ref3$scrollLeft === void 0 ? states.value.scrollLeft : _ref3$scrollLeft,\n          _ref3$scrollTop = _ref3.scrollTop,\n          scrollTop = _ref3$scrollTop === void 0 ? states.value.scrollTop : _ref3$scrollTop;\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n        var _states = unref(states);\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          updateRequested: true\n        });\n        nextTick(function () {\n          return resetIsScrolling();\n        });\n        onUpdated();\n        emitEvents();\n      };\n      var scrollToItem = function scrollToItem() {\n        var rowIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var columnIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var alignment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AUTO_ALIGNMENT;\n        var _states = unref(states);\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        var scrollBarWidth = getScrollBarWidth(ns.namespace.value);\n        var _cache = unref(cache);\n        var estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        var estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n      var getItemStyle = function getItemStyle(rowIndex, columnIndex) {\n        var columnWidth = props.columnWidth,\n          direction = props.direction,\n          rowHeight = props.rowHeight;\n        var itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        var key = \"\".concat(rowIndex, \",\").concat(columnIndex);\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          var _getColumnPosition = getColumnPosition(props, columnIndex, unref(cache)),\n            _getColumnPosition2 = _slicedToArray(_getColumnPosition, 2),\n            left = _getColumnPosition2[1];\n          var _cache = unref(cache);\n          var rtl = isRTL(direction);\n          var _getRowPosition = getRowPosition(props, rowIndex, _cache),\n            _getRowPosition2 = _slicedToArray(_getRowPosition, 2),\n            height = _getRowPosition2[0],\n            top = _getRowPosition2[1];\n          var _getColumnPosition3 = getColumnPosition(props, columnIndex, _cache),\n            _getColumnPosition4 = _slicedToArray(_getColumnPosition3, 1),\n            width = _getColumnPosition4[0];\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : \"\".concat(left, \"px\"),\n            right: rtl ? \"\".concat(left, \"px\") : void 0,\n            top: \"\".concat(top, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            width: \"\".concat(width, \"px\")\n          };\n          return itemStyleCache[key];\n        }\n      };\n      var resetIsScrolling = function resetIsScrolling() {\n        states.value.isScrolling = false;\n        nextTick(function () {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      onMounted(function () {\n        if (!isClient) return;\n        var initScrollLeft = props.initScrollLeft,\n          initScrollTop = props.initScrollTop;\n        var windowElement = unref(windowRef);\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n        emitEvents();\n      });\n      var onUpdated = function onUpdated() {\n        var direction = props.direction;\n        var _unref8 = unref(states),\n          scrollLeft = _unref8.scrollLeft,\n          scrollTop = _unref8.scrollTop,\n          updateRequested = _unref8.updateRequested;\n        var windowElement = unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n              case RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n              default:\n                {\n                  var clientWidth = windowElement.clientWidth,\n                    scrollWidth = windowElement.scrollWidth;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      };\n      var _instance$proxy = instance.proxy,\n        resetAfterColumnIndex = _instance$proxy.resetAfterColumnIndex,\n        resetAfterRowIndex = _instance$proxy.resetAfterRowIndex,\n        resetAfter = _instance$proxy.resetAfter;\n      expose({\n        windowRef: windowRef,\n        innerRef: innerRef,\n        getItemStyleCache: getItemStyleCache,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        states: states,\n        resetAfterColumnIndex: resetAfterColumnIndex,\n        resetAfterRowIndex: resetAfterRowIndex,\n        resetAfter: resetAfter\n      });\n      var renderScrollbars = function renderScrollbars() {\n        var scrollbarAlwaysOn = props.scrollbarAlwaysOn,\n          scrollbarStartGap = props.scrollbarStartGap,\n          scrollbarEndGap = props.scrollbarEndGap,\n          totalColumn = props.totalColumn,\n          totalRow = props.totalRow;\n        var width = unref(parsedWidth);\n        var height = unref(parsedHeight);\n        var estimatedWidth = unref(estimatedTotalWidth);\n        var estimatedHeight = unref(estimatedTotalHeight);\n        var _unref9 = unref(states),\n          scrollLeft = _unref9.scrollLeft,\n          scrollTop = _unref9.scrollTop;\n        var horizontalScrollbar = h(ScrollBar, {\n          ref: hScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          \"class\": ns.e(\"horizontal\"),\n          clientSize: width,\n          layout: \"horizontal\",\n          onScroll: onHorizontalScroll,\n          ratio: width * 100 / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true\n        });\n        var verticalScrollbar = h(ScrollBar, {\n          ref: vScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          \"class\": ns.e(\"vertical\"),\n          clientSize: height,\n          layout: \"vertical\",\n          onScroll: onVerticalScroll,\n          ratio: height * 100 / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true\n        });\n        return {\n          horizontalScrollbar: horizontalScrollbar,\n          verticalScrollbar: verticalScrollbar\n        };\n      };\n      var renderItems = function renderItems() {\n        var _a;\n        var _unref10 = unref(columnsToRender),\n          _unref11 = _slicedToArray(_unref10, 2),\n          columnStart = _unref11[0],\n          columnEnd = _unref11[1];\n        var _unref12 = unref(rowsToRender),\n          _unref13 = _slicedToArray(_unref12, 2),\n          rowStart = _unref13[0],\n          rowEnd = _unref13[1];\n        var data = props.data,\n          totalColumn = props.totalColumn,\n          totalRow = props.totalRow,\n          useIsScrolling = props.useIsScrolling,\n          itemKey = props.itemKey;\n        var children = [];\n        if (totalRow > 0 && totalColumn > 0) {\n          for (var row = rowStart; row <= rowEnd; row++) {\n            for (var column = columnStart; column <= columnEnd; column++) {\n              var key = itemKey({\n                columnIndex: column,\n                data: data,\n                rowIndex: row\n              });\n              children.push(h(Fragment, {\n                key: key\n              }, (_a = slots[\"default\"]) == null ? void 0 : _a.call(slots, {\n                columnIndex: column,\n                data: data,\n                isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,\n                style: getItemStyle(row, column),\n                rowIndex: row\n              })));\n            }\n          }\n        }\n        return children;\n      };\n      var renderInner = function renderInner() {\n        var Inner = resolveDynamicComponent(props.innerElement);\n        var children = renderItems();\n        return [h(Inner, {\n          style: unref(innerStyle),\n          ref: innerRef\n        }, !isString(Inner) ? {\n          \"default\": function _default() {\n            return children;\n          }\n        } : children)];\n      };\n      var renderWindow = function renderWindow() {\n        var Container = resolveDynamicComponent(props.containerElement);\n        var _renderScrollbars = renderScrollbars(),\n          horizontalScrollbar = _renderScrollbars.horizontalScrollbar,\n          verticalScrollbar = _renderScrollbars.verticalScrollbar;\n        var Inner = renderInner();\n        return h(\"div\", {\n          key: 0,\n          \"class\": ns.e(\"wrapper\"),\n          role: props.role\n        }, [h(Container, {\n          \"class\": props.className,\n          style: unref(windowStyle),\n          onScroll: onScroll,\n          ref: windowRef\n        }, !isString(Container) ? {\n          \"default\": function _default() {\n            return Inner;\n          }\n        } : Inner), horizontalScrollbar, verticalScrollbar]);\n      };\n      return renderWindow;\n    }\n  });\n};\nexport { createGrid as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}