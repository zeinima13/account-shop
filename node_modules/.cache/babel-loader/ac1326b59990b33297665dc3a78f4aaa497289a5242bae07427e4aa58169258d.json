{"ast":null,"code":"import _typeof from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport createList from '../builders/build-list.mjs';\nimport { isHorizontal } from '../utils.mjs';\nimport { AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, DEFAULT_DYNAMIC_LIST_ITEM_SIZE, SMART_ALIGNMENT } from '../defaults.mjs';\nimport { throwError } from '../../../../utils/error.mjs';\nvar SCOPE = \"ElDynamicSizeList\";\nvar getItemFromCache = function getItemFromCache(props, index, listCache) {\n  var itemSize = props.itemSize;\n  var items = listCache.items,\n    lastVisitedIndex = listCache.lastVisitedIndex;\n  if (index > lastVisitedIndex) {\n    var offset = 0;\n    if (lastVisitedIndex >= 0) {\n      var item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n    for (var i = lastVisitedIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      items[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n    listCache.lastVisitedIndex = index;\n  }\n  return items[index];\n};\nvar findItem = function findItem(props, listCache, offset) {\n  var items = listCache.items,\n    lastVisitedIndex = listCache.lastVisitedIndex;\n  var lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\nvar bs = function bs(props, listCache, low, high, offset) {\n  while (low <= high) {\n    var mid = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemFromCache(props, mid, listCache).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n  return Math.max(0, low - 1);\n};\nvar es = function es(props, listCache, index, offset) {\n  var total = props.total;\n  var exponent = 1;\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref, _ref2) {\n  var total = _ref.total;\n  var items = _ref2.items,\n    estimatedItemSize = _ref2.estimatedItemSize,\n    lastVisitedIndex = _ref2.lastVisitedIndex;\n  var totalSizeOfMeasuredItems = 0;\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n  if (lastVisitedIndex >= 0) {\n    var item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n  var numUnmeasuredItems = total - lastVisitedIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\nvar DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: function getItemOffset(props, index, listCache) {\n    return getItemFromCache(props, index, listCache).offset;\n  },\n  getItemSize: function getItemSize(_, index, _ref3) {\n    var items = _ref3.items;\n    return items[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffset: function getOffset(props, index, alignment, scrollOffset, listCache) {\n    var height = props.height,\n      layout = props.layout,\n      width = props.width;\n    var size = isHorizontal(layout) ? width : height;\n    var item = getItemFromCache(props, index, listCache);\n    var estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    var minOffset = Math.max(0, item.offset - size + item.size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n      case CENTERED_ALIGNMENT:\n        {\n          return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, listCache) {\n    return findItem(props, listCache, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, listCache) {\n    var height = props.height,\n      total = props.total,\n      layout = props.layout,\n      width = props.width;\n    var size = isHorizontal(layout) ? width : height;\n    var item = getItemFromCache(props, startIndex, listCache);\n    var maxOffset = scrollOffset + size;\n    var offset = item.offset + item.size;\n    var stopIndex = startIndex;\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n    return stopIndex;\n  },\n  initCache: function initCache(_ref4, instance) {\n    var _ref4$estimatedItemSi = _ref4.estimatedItemSize,\n      estimatedItemSize = _ref4$estimatedItemSi === void 0 ? DEFAULT_DYNAMIC_LIST_ITEM_SIZE : _ref4$estimatedItemSi;\n    var cache = {\n      items: {},\n      estimatedItemSize: estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n    cache.clearCacheAfterIndex = function (index) {\n      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var _a, _b;\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache(-1);\n      if (forceUpdate) {\n        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n      }\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, \"\\n          itemSize is required as function, but the given value was \".concat(_typeof(itemSize), \"\\n        \"));\n      }\n    }\n  }\n});\nexport { DynamicSizeList as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}