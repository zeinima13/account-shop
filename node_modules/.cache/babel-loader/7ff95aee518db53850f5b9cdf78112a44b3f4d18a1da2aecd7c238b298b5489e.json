{"ast":null,"code":"import _objectSpread from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { ref, getCurrentInstance, computed, watch, unref } from 'vue';\nimport { getRowIdentity, walkTreeNode } from '../util.mjs';\nimport { isArray } from '@vue/shared';\nimport { isUndefined } from '../../../../utils/types.mjs';\nfunction useTree(watcherData) {\n  var expandRowKeys = ref([]);\n  var treeData = ref({});\n  var indent = ref(16);\n  var lazy = ref(false);\n  var lazyTreeNodeMap = ref({});\n  var lazyColumnIdentifier = ref(\"hasChildren\");\n  var childrenColumnName = ref(\"children\");\n  var checkStrictly = ref(false);\n  var instance = getCurrentInstance();\n  var normalizedData = computed(function () {\n    if (!watcherData.rowKey.value) return {};\n    var data = watcherData.data.value || [];\n    return normalize(data);\n  });\n  var normalizedLazyNode = computed(function () {\n    var rowKey = watcherData.rowKey.value;\n    var keys = Object.keys(lazyTreeNodeMap.value);\n    var res = {};\n    if (!keys.length) return res;\n    keys.forEach(function (key) {\n      if (lazyTreeNodeMap.value[key].length) {\n        var item = {\n          children: []\n        };\n        lazyTreeNodeMap.value[key].forEach(function (row) {\n          var currentRowKey = getRowIdentity(row, rowKey);\n          item.children.push(currentRowKey);\n          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {\n            res[currentRowKey] = {\n              children: []\n            };\n          }\n        });\n        res[key] = item;\n      }\n    });\n    return res;\n  });\n  var normalize = function normalize(data) {\n    var rowKey = watcherData.rowKey.value;\n    var res = {};\n    walkTreeNode(data, function (parent, children, level) {\n      var parentId = getRowIdentity(parent, rowKey);\n      if (isArray(children)) {\n        res[parentId] = {\n          children: children.map(function (row) {\n            return getRowIdentity(row, rowKey);\n          }),\n          level: level\n        };\n      } else if (lazy.value) {\n        res[parentId] = {\n          children: [],\n          lazy: true,\n          level: level\n        };\n      }\n    }, childrenColumnName.value, lazyColumnIdentifier.value);\n    return res;\n  };\n  var updateTreeData = function updateTreeData() {\n    var ifChangeExpandRowKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var ifExpandAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (_a) {\n      return (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value;\n    }();\n    var _a2;\n    var nested = normalizedData.value;\n    var normalizedLazyNode_ = normalizedLazyNode.value;\n    var keys = Object.keys(nested);\n    var newTreeData = {};\n    if (keys.length) {\n      var oldTreeData = unref(treeData);\n      var rootLazyRowKeys = [];\n      var getExpanded = function getExpanded(oldValue, key) {\n        if (ifChangeExpandRowKeys) {\n          if (expandRowKeys.value) {\n            return ifExpandAll || expandRowKeys.value.includes(key);\n          } else {\n            return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));\n          }\n        } else {\n          var included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);\n          return !!((oldValue == null ? void 0 : oldValue.expanded) || included);\n        }\n      };\n      keys.forEach(function (key) {\n        var oldValue = oldTreeData[key];\n        var newValue = _objectSpread({}, nested[key]);\n        newValue.expanded = getExpanded(oldValue, key);\n        if (newValue.lazy) {\n          var _ref = oldValue || {},\n            _ref$loaded = _ref.loaded,\n            loaded = _ref$loaded === void 0 ? false : _ref$loaded,\n            _ref$loading = _ref.loading,\n            loading = _ref$loading === void 0 ? false : _ref$loading;\n          newValue.loaded = !!loaded;\n          newValue.loading = !!loading;\n          rootLazyRowKeys.push(key);\n        }\n        newTreeData[key] = newValue;\n      });\n      var lazyKeys = Object.keys(normalizedLazyNode_);\n      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {\n        lazyKeys.forEach(function (key) {\n          var oldValue = oldTreeData[key];\n          var lazyNodeChildren = normalizedLazyNode_[key].children;\n          if (rootLazyRowKeys.includes(key)) {\n            if (newTreeData[key].children.length !== 0) {\n              throw new Error(\"[ElTable]children must be an empty array.\");\n            }\n            newTreeData[key].children = lazyNodeChildren;\n          } else {\n            var _ref2 = oldValue || {},\n              _ref2$loaded = _ref2.loaded,\n              loaded = _ref2$loaded === void 0 ? false : _ref2$loaded,\n              _ref2$loading = _ref2.loading,\n              loading = _ref2$loading === void 0 ? false : _ref2$loading;\n            newTreeData[key] = {\n              lazy: true,\n              loaded: !!loaded,\n              loading: !!loading,\n              expanded: getExpanded(oldValue, key),\n              children: lazyNodeChildren,\n              level: \"\"\n            };\n          }\n        });\n      }\n    }\n    treeData.value = newTreeData;\n    (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();\n  };\n  watch(function () {\n    return expandRowKeys.value;\n  }, function () {\n    updateTreeData(true);\n  });\n  watch(function () {\n    return normalizedData.value;\n  }, function () {\n    updateTreeData();\n  });\n  watch(function () {\n    return normalizedLazyNode.value;\n  }, function () {\n    updateTreeData();\n  });\n  var updateTreeExpandKeys = function updateTreeExpandKeys(value) {\n    expandRowKeys.value = value;\n    updateTreeData();\n  };\n  var toggleTreeExpansion = function toggleTreeExpansion(row, expanded) {\n    instance.store.assertRowKey();\n    var rowKey = watcherData.rowKey.value;\n    var id = getRowIdentity(row, rowKey);\n    var data = id && treeData.value[id];\n    if (id && data && \"expanded\" in data) {\n      var oldExpanded = data.expanded;\n      expanded = isUndefined(expanded) ? !data.expanded : expanded;\n      treeData.value[id].expanded = expanded;\n      if (oldExpanded !== expanded) {\n        instance.emit(\"expand-change\", row, expanded);\n      }\n      instance.store.updateTableScrollY();\n    }\n  };\n  var loadOrToggle = function loadOrToggle(row) {\n    instance.store.assertRowKey();\n    var rowKey = watcherData.rowKey.value;\n    var id = getRowIdentity(row, rowKey);\n    var data = treeData.value[id];\n    if (lazy.value && data && \"loaded\" in data && !data.loaded) {\n      loadData(row, id, data);\n    } else {\n      toggleTreeExpansion(row, void 0);\n    }\n  };\n  var loadData = function loadData(row, key, treeNode) {\n    var load = instance.props.load;\n    if (load && !treeData.value[key].loaded) {\n      treeData.value[key].loading = true;\n      load(row, treeNode, function (data) {\n        if (!isArray(data)) {\n          throw new TypeError(\"[ElTable] data must be an array\");\n        }\n        treeData.value[key].loading = false;\n        treeData.value[key].loaded = true;\n        treeData.value[key].expanded = true;\n        if (data.length) {\n          lazyTreeNodeMap.value[key] = data;\n        }\n        instance.emit(\"expand-change\", row, true);\n      });\n    }\n  };\n  var updateKeyChildren = function updateKeyChildren(key, data) {\n    var _instance$props = instance.props,\n      lazy2 = _instance$props.lazy,\n      rowKey = _instance$props.rowKey;\n    if (!lazy2) return;\n    if (!rowKey) throw new Error(\"[Table] rowKey is required in updateKeyChild\");\n    if (lazyTreeNodeMap.value[key]) {\n      lazyTreeNodeMap.value[key] = data;\n    }\n  };\n  return {\n    loadData: loadData,\n    loadOrToggle: loadOrToggle,\n    toggleTreeExpansion: toggleTreeExpansion,\n    updateTreeExpandKeys: updateTreeExpandKeys,\n    updateTreeData: updateTreeData,\n    updateKeyChildren: updateKeyChildren,\n    normalize: normalize,\n    states: {\n      expandRowKeys: expandRowKeys,\n      treeData: treeData,\n      indent: indent,\n      lazy: lazy,\n      lazyTreeNodeMap: lazyTreeNodeMap,\n      lazyColumnIdentifier: lazyColumnIdentifier,\n      childrenColumnName: childrenColumnName,\n      checkStrictly: checkStrictly\n    }\n  };\n}\nexport { useTree as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}