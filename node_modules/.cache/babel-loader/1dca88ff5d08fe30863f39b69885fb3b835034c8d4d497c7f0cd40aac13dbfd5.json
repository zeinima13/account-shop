{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/ASUS/CascadeProjects/account-shop/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { ref, onMounted, watch, onBeforeUnmount, computed, unref, watchEffect } from 'vue';\nimport { offset, flip, shift, detectOverflow, arrow, computePosition, autoUpdate } from '@floating-ui/dom';\nimport { isArray, isString, isFunction } from '@vue/shared';\nimport { isClient } from '@vueuse/core';\nimport { keysOf } from '../../../utils/objects.mjs';\nvar useTarget = function useTarget(target, open, gap, mergedMask, scrollIntoViewOptions) {\n  var posInfo = ref(null);\n  var getTargetEl = function getTargetEl() {\n    var targetEl;\n    if (isString(target.value)) {\n      targetEl = document.querySelector(target.value);\n    } else if (isFunction(target.value)) {\n      targetEl = target.value();\n    } else {\n      targetEl = target.value;\n    }\n    return targetEl;\n  };\n  var updatePosInfo = function updatePosInfo() {\n    var targetEl = getTargetEl();\n    if (!targetEl || !open.value) {\n      posInfo.value = null;\n      return;\n    }\n    if (!isInViewPort(targetEl)) {\n      targetEl.scrollIntoView(scrollIntoViewOptions.value);\n    }\n    var _targetEl$getBounding = targetEl.getBoundingClientRect(),\n      left = _targetEl$getBounding.left,\n      top = _targetEl$getBounding.top,\n      width = _targetEl$getBounding.width,\n      height = _targetEl$getBounding.height;\n    posInfo.value = {\n      left: left,\n      top: top,\n      width: width,\n      height: height,\n      radius: 0\n    };\n  };\n  onMounted(function () {\n    watch([open, target], function () {\n      updatePosInfo();\n    }, {\n      immediate: true\n    });\n    window.addEventListener(\"resize\", updatePosInfo);\n  });\n  onBeforeUnmount(function () {\n    window.removeEventListener(\"resize\", updatePosInfo);\n  });\n  var getGapOffset = function getGapOffset(index) {\n    var _a;\n    return (_a = isArray(gap.value.offset) ? gap.value.offset[index] : gap.value.offset) != null ? _a : 6;\n  };\n  var mergedPosInfo = computed(function () {\n    var _a;\n    if (!posInfo.value) return posInfo.value;\n    var gapOffsetX = getGapOffset(0);\n    var gapOffsetY = getGapOffset(1);\n    var gapRadius = ((_a = gap.value) == null ? void 0 : _a.radius) || 2;\n    return {\n      left: posInfo.value.left - gapOffsetX,\n      top: posInfo.value.top - gapOffsetY,\n      width: posInfo.value.width + gapOffsetX * 2,\n      height: posInfo.value.height + gapOffsetY * 2,\n      radius: gapRadius\n    };\n  });\n  var triggerTarget = computed(function () {\n    var targetEl = getTargetEl();\n    if (!mergedMask.value || !targetEl || !window.DOMRect) {\n      return targetEl || void 0;\n    }\n    return {\n      getBoundingClientRect: function getBoundingClientRect() {\n        var _a, _b, _c, _d;\n        return window.DOMRect.fromRect({\n          width: ((_a = mergedPosInfo.value) == null ? void 0 : _a.width) || 0,\n          height: ((_b = mergedPosInfo.value) == null ? void 0 : _b.height) || 0,\n          x: ((_c = mergedPosInfo.value) == null ? void 0 : _c.left) || 0,\n          y: ((_d = mergedPosInfo.value) == null ? void 0 : _d.top) || 0\n        });\n      }\n    };\n  });\n  return {\n    mergedPosInfo: mergedPosInfo,\n    triggerTarget: triggerTarget\n  };\n};\nvar tourKey = Symbol(\"ElTour\");\nfunction isInViewPort(element) {\n  var viewWidth = window.innerWidth || document.documentElement.clientWidth;\n  var viewHeight = window.innerHeight || document.documentElement.clientHeight;\n  var _element$getBoundingC = element.getBoundingClientRect(),\n    top = _element$getBoundingC.top,\n    right = _element$getBoundingC.right,\n    bottom = _element$getBoundingC.bottom,\n    left = _element$getBoundingC.left;\n  return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;\n}\nvar useFloating = function useFloating(referenceRef, contentRef, arrowRef, placement, strategy, offset$1, zIndex, showArrow) {\n  var x = ref();\n  var y = ref();\n  var middlewareData = ref({});\n  var states = {\n    x: x,\n    y: y,\n    placement: placement,\n    strategy: strategy,\n    middlewareData: middlewareData\n  };\n  var middleware = computed(function () {\n    var _middleware = [offset(unref(offset$1)), flip(), shift(), overflowMiddleware()];\n    if (unref(showArrow) && unref(arrowRef)) {\n      _middleware.push(arrow({\n        element: unref(arrowRef)\n      }));\n    }\n    return _middleware;\n  });\n  var update = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var referenceEl, contentEl, data;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (isClient) {\n              _context.next = 2;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 2:\n            referenceEl = unref(referenceRef);\n            contentEl = unref(contentRef);\n            if (!(!referenceEl || !contentEl)) {\n              _context.next = 6;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 6:\n            _context.next = 8;\n            return computePosition(referenceEl, contentEl, {\n              placement: unref(placement),\n              strategy: unref(strategy),\n              middleware: unref(middleware)\n            });\n          case 8:\n            data = _context.sent;\n            keysOf(states).forEach(function (key) {\n              states[key].value = data[key];\n            });\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function update() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  var contentStyle = computed(function () {\n    if (!unref(referenceRef)) {\n      return {\n        position: \"fixed\",\n        top: \"50%\",\n        left: \"50%\",\n        transform: \"translate3d(-50%, -50%, 0)\",\n        maxWidth: \"100vw\",\n        zIndex: unref(zIndex)\n      };\n    }\n    var _unref = unref(middlewareData),\n      overflow = _unref.overflow;\n    return {\n      position: unref(strategy),\n      zIndex: unref(zIndex),\n      top: unref(y) != null ? \"\".concat(unref(y), \"px\") : \"\",\n      left: unref(x) != null ? \"\".concat(unref(x), \"px\") : \"\",\n      maxWidth: (overflow == null ? void 0 : overflow.maxWidth) ? \"\".concat(overflow == null ? void 0 : overflow.maxWidth, \"px\") : \"\"\n    };\n  });\n  var arrowStyle = computed(function () {\n    if (!unref(showArrow)) return {};\n    var _unref2 = unref(middlewareData),\n      arrow2 = _unref2.arrow;\n    return {\n      left: (arrow2 == null ? void 0 : arrow2.x) != null ? \"\".concat(arrow2 == null ? void 0 : arrow2.x, \"px\") : \"\",\n      top: (arrow2 == null ? void 0 : arrow2.y) != null ? \"\".concat(arrow2 == null ? void 0 : arrow2.y, \"px\") : \"\"\n    };\n  });\n  var cleanup;\n  onMounted(function () {\n    var referenceEl = unref(referenceRef);\n    var contentEl = unref(contentRef);\n    if (referenceEl && contentEl) {\n      cleanup = autoUpdate(referenceEl, contentEl, update);\n    }\n    watchEffect(function () {\n      update();\n    });\n  });\n  onBeforeUnmount(function () {\n    cleanup && cleanup();\n  });\n  return {\n    update: update,\n    contentStyle: contentStyle,\n    arrowStyle: arrowStyle\n  };\n};\nvar overflowMiddleware = function overflowMiddleware() {\n  return {\n    name: \"overflow\",\n    fn: function fn(state) {\n      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var overflow, overWidth, floatingWidth;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return detectOverflow(state);\n            case 2:\n              overflow = _context2.sent;\n              overWidth = 0;\n              if (overflow.left > 0) overWidth = overflow.left;\n              if (overflow.right > 0) overWidth = overflow.right;\n              floatingWidth = state.rects.floating.width;\n              return _context2.abrupt(\"return\", {\n                data: {\n                  maxWidth: floatingWidth - overWidth\n                }\n              });\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }))();\n    }\n  };\n};\nexport { tourKey, useFloating, useTarget };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}